<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://alishdipani.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://alishdipani.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-03T16:17:09+00:00</updated><id>https://alishdipani.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">IRuby integration and ticks</title><link href="https://alishdipani.github.io/gsoc2019/2019/08/22/IRuby-integration-and-ticks/" rel="alternate" type="text/html" title="IRuby integration and ticks"/><published>2019-08-22T12:00:00+00:00</published><updated>2019-08-22T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/08/22/IRuby-integration-and-ticks</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/08/22/IRuby-integration-and-ticks/"><![CDATA[<p>Summary: iruby integration and ticks.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#iruby-integration" id="markdown-toc-iruby-integration">IRuby integration</a> <ul> <li><a href="#what-are-iruby-notebooks" id="markdown-toc-what-are-iruby-notebooks">What are IRuby notebooks?</a></li> <li><a href="#integration-of-rubyplot-with-iruby-notebooks" id="markdown-toc-integration-of-rubyplot-with-iruby-notebooks">Integration of Rubyplot with IRuby notebooks</a> <ul> <li><a href="#inline-plots" id="markdown-toc-inline-plots">inline plots</a></li> </ul> </li> </ul> </li> <li><a href="#ticks" id="markdown-toc-ticks">Ticks</a> <ul> <li><a href="#major-ticks" id="markdown-toc-major-ticks">Major ticks</a></li> <li><a href="#minor-ticks" id="markdown-toc-minor-ticks">Minor ticks</a></li> </ul> </li> </ul> <h1 id="introduction">Introduction</h1> <p>This blog explains the integration of Rubyplot with IRuby notebooks and ticks in Rubyplot and highlights the work done during Week 9, 10, 11 and 12 for GSoC 2019.</p> <h1 id="iruby-integration">IRuby integration</h1> <h2 id="what-are-iruby-notebooks">What are IRuby notebooks?</h2> <p>IRuby is a Ruby kernel for Jupyter project. Similar to IPython notebooks, it is a interactive computational environment where you can combine code execution, text, mathematics, plots and rich media into a single document. It can run on any browser.<br/> An example is -</p> <h2 id="integration-of-rubyplot-with-iruby-notebooks">Integration of Rubyplot with IRuby notebooks</h2> <h3 id="inline-plots">inline plots</h3> <h1 id="ticks">Ticks</h1> <h2 id="major-ticks">Major ticks</h2> <h2 id="minor-ticks">Minor ticks</h2>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: iruby integration and ticks.]]></summary></entry><entry><title type="html">Wrapping up GSoC 2019</title><link href="https://alishdipani.github.io/gsoc2019/2019/08/22/Wrapping-up-GSoC-2019/" rel="alternate" type="text/html" title="Wrapping up GSoC 2019"/><published>2019-08-22T12:00:00+00:00</published><updated>2019-08-22T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/08/22/Wrapping-up-GSoC-2019</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/08/22/Wrapping-up-GSoC-2019/"><![CDATA[<p>Summary: The final blog for GSoC 2019.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#what-is-rubyplot" id="markdown-toc-what-is-rubyplot">What is Rubyplot?</a> <ul> <li><a href="#examples" id="markdown-toc-examples">Examples</a></li> </ul> </li> <li><a href="#history-of-rubyplot" id="markdown-toc-history-of-rubyplot">History of Rubyplot</a></li> <li><a href="#gsoc-2019" id="markdown-toc-gsoc-2019">GSoC 2019</a> <ul> <li><a href="#phase-1" id="markdown-toc-phase-1">Phase 1</a></li> <li><a href="#phase-2" id="markdown-toc-phase-2">Phase 2</a></li> <li><a href="#phase-3" id="markdown-toc-phase-3">Phase 3</a></li> </ul> </li> <li><a href="#resourcesblogs-code-etc" id="markdown-toc-resourcesblogs-code-etc">Resources(blogs, code, etc.)</a> <ul> <li><a href="#previous-work" id="markdown-toc-previous-work">Previous Work</a></li> <li><a href="#my-work" id="markdown-toc-my-work">My work</a></li> </ul> </li> <li><a href="#future-work" id="markdown-toc-future-work">Future Work</a></li> <li><a href="#endnote" id="markdown-toc-endnote">EndNote</a></li> <li><a href="#acknowledgements" id="markdown-toc-acknowledgements">Acknowledgements</a></li> </ul> <h1 id="introduction">Introduction</h1> <p>With GSoC 2019 coming to an end, this is my final blog which mentions all my work for the project Rubyplot.</p> <h1 id="what-is-rubyplot">What is Rubyplot?</h1> <p>RubyPlot is a plotting library in Ruby for scientific development inspired by the library Matplotlib for Python. Users can create various types of plots like scatter plot, bar plot, etc. and can also create subplots which combine various of these plots. The long-term goal of the library is to build an efficient, scalable and user-friendly library with a backend-agnostic frontend to support various backends so that the library can be used on any device.</p> <h2 id="examples">Examples</h2> <p>Creating graphs in Rubyplot is very simple and can be done in just a few lines of code, for example:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rubyplot'</span>

<span class="n">figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">width: </span><span class="mi">30</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">30</span><span class="p">)</span>

<span class="n">axes00</span> <span class="o">=</span> <span class="n">figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">plot!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">360</span><span class="p">).</span><span class="nf">step</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="no">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="p">}</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">fmt</span> <span class="o">=</span> <span class="s1">'ok-'</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:white</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_size</span> <span class="o">=</span> <span class="mf">0.5</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">line_width</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"sine"</span>
<span class="k">end</span>

<span class="n">axes00</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"A plot function example"</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">square_axes</span> <span class="o">=</span> <span class="kp">false</span>

<span class="n">figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'example1.png'</span><span class="p">)</span>
</code></pre></div></div> <p>Has the output:<br/> <img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Wrapping_up_GSoC_2019/example1.png" width="600"/></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rubyplot'</span>

<span class="n">figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">width: </span><span class="mi">30</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">30</span><span class="p">)</span>

<span class="n">axes00</span> <span class="o">=</span> <span class="n">figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">candle_stick!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">lows</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span> 
  <span class="nb">p</span><span class="p">.</span><span class="nf">highs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span> 
  <span class="nb">p</span><span class="p">.</span><span class="nf">opens</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">closes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">]</span> 
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:yellow</span>
<span class="k">end</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">candle_stick!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">lows</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">highs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">60</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">opens</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span> 
  <span class="nb">p</span><span class="p">.</span><span class="nf">closes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">35</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:blue</span>
<span class="k">end</span>

<span class="n">axes00</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"A multi candle-stick plot"</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">square_axes</span> <span class="o">=</span> <span class="kp">false</span>

<span class="n">figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'example2.png'</span><span class="p">)</span>
</code></pre></div></div> <p>Has the output:<br/> <img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Wrapping_up_GSoC_2019/example2.png" width="600"/></p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'rubyplot'</span>

<span class="n">figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">width: </span><span class="mi">30</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">30</span><span class="p">)</span>

<span class="n">axes00</span> <span class="o">=</span> <span class="n">figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">bar!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:lemon</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">spacing_ratio</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="k">end</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">bar!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:blue</span>
<span class="k">end</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">bar!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:red</span>
<span class="k">end</span>

<span class="n">axes00</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"A multi bar plot"</span>
<span class="n">axes00</span><span class="p">.</span><span class="nf">square_axes</span> <span class="o">=</span> <span class="kp">false</span>

<span class="n">figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'example3.png'</span><span class="p">)</span>
</code></pre></div></div> <p>Has the output:<br/> <img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Wrapping_up_GSoC_2019/example3.png" width="600"/></p> <h1 id="history-of-rubyplot">History of Rubyplot</h1> <p>Rubyplot started as two GSoC 2018 projects by Pranav Garg<a href="https://github.com/pgtgrly">(@pgtgrly)</a> and Arafat Dad Khan<a href="https://github.com/Arafatk">(@Arafatk)</a> and the mentors from The Ruby Science Foundation<a href="http://sciruby.com/">(SciRuby)</a>, Sameer Deshmukh<a href="https://github.com/v0dro">(@v0dro)</a>, John Woods<a href="https://github.com/mohawkjohn">(@mohawkjohn)</a> and Pjotr Prins<a href="https://github.com/pjotrp">(@pjotrp)</a>. Pranav Garg worked on the GRRuby which had the GR backend and Arafat Dad Khan worked on Ruby Matplotlib which had the ImageMagick backend. The ultimate goal of combining both and creating Rubyplot. After GSoC 2018, Sameer Deshmukh combined both projects and created Rubyplot and he has maintained it ever since. Around May 2019, I started working on Rubyplot as a part of GSoC 2019.</p> <h1 id="gsoc-2019">GSoC 2019</h1> <p>As a part of GSoC 2019, my project had 3 major deliverables:</p> <ol> <li><strong>ImageMagick support</strong>(Phase 1): Support for ImageMagick back-end will be added in addition to the currently supported back-end GR, the front-end of the library will be back-end agnostic and the current overall integrity of the library will be preserved.</li> <li><strong>Plotting and show function</strong>(Phase 2): A new plot function will be added which plots markers (for example circles) to form a scatter plot with the points as inputs (same as plot function in Matplotlib). A new function show will be added which will allow viewing of a plot without saving it. This plot function will be back-end agnostic and hence will support both GR and Magick back-end.</li> <li><strong>Integration with iruby notebooks</strong>(Phase 3): Rubyplot will be integrated with iruby notebooks supporting all backends and allowing inline plotting.</li> </ol> <p>As a part of GSoC 2019, I completed all the deliverables I had initially planned along with a tutorial for the library and some other general improvements.<br/> Details of my work are as follows:</p> <h2 id="phase-1">Phase 1</h2> <p>During Phase 1, I focused on setting up the ImageMagick backend which involved the basic functionality required for any backend of the library which are X-axis and Y-axis transform functions, <code class="language-plaintext highlighter-rouge">within_window</code> function which is responsible for placing the plots in the correct position, function for drawing the X and Y axis, functions for drawing the text and scaling the figure according to the dimensions given by the user. I implemented these functions using internal rmagick functions which were very useful like <code class="language-plaintext highlighter-rouge">scale</code>, <code class="language-plaintext highlighter-rouge">translate</code>, <code class="language-plaintext highlighter-rouge">rotate</code>, etc.<br/> After this, I worked on the scatter plot, which was the first plot I ever worked on. This plot had a very particular and interesting problem, which was that different types of markers were internally implemented in the GR backend, but for ImageMagick backend, I had to implement everything using basic shapes like circles, lines, polygons and rectangles. To solve this I created a hash of lambdas which had the code to create different types of markers using the basic shapes.<br/> After this I implemented all the simple plots which Rubyplot supports, these are line plot, area plot, bar plot, histogram, box plot, bubble plot, candle-stick plot and error-bar plot.</p> <p>So, during Phase 1, I completed the following deliverables -</p> <ol> <li>Set up the ImageMagick backend to have the basic functionality.</li> <li>Implemented and tested the simple plots in Rubyplot which are scatter plot, line plot, area plot, bar plot, histogram, box plot, bubble plot, candle-stick plot and error-bar plot.</li> </ol> <p>Code for Phase 1 can be found <a href="https://github.com/SciRuby/rubyplot/pull/45/files/01a26777175c83e3e44a33d5ac5d6544b8ff9353..95f24730e04eb13460ed088dcf7569848b66a2ea">here</a>.</p> <h2 id="phase-2">Phase 2</h2> <p>I started Phase 2 by implementing the multi plots which are multi stack-bar plot, multi-bar plot, multi-box plot and multi candle-stick plot.<br/> Next, I implemented the <code class="language-plaintext highlighter-rouge">plot</code> function which is a combination of scatter plot and line plot, using the plot function the user can easily create a scatter plot or a line plot or a combination of both. The most interesting feature of the <code class="language-plaintext highlighter-rouge">plot</code> function is the <code class="language-plaintext highlighter-rouge">fmt</code> argument which sets the marker type, line type and the colour of the plot using just characters, so instead of writing the name of the type and setting the variables, the user can simply input a string in <code class="language-plaintext highlighter-rouge">fmt</code> argument which has the characters for corresponding marker type, line type and colour.<br/> Next was to implement the <code class="language-plaintext highlighter-rouge">show</code> function which is an alternative to <code class="language-plaintext highlighter-rouge">write</code> function. It draws the Figure and shows it on a temporary pop-up window without the need of saving the Figure on the device, this allows the user to test the code quickly and easily. This was done by using internal functions of the backends which are <code class="language-plaintext highlighter-rouge">display</code> for ImageMagick and <code class="language-plaintext highlighter-rouge">gr_updatews</code> for GR.</p> <p>So, during Phase 2, I completed the following deliverables -</p> <ol> <li>Implemented and tested the multi plots in Rubyplot which are multi stack-bar plot, multi-bar plot, multi-box plot and multi candle-stick plot.</li> <li>Implemented and tested the <code class="language-plaintext highlighter-rouge">plot</code> function with fmt argument.</li> <li>Implemented and tested the <code class="language-plaintext highlighter-rouge">show</code> function.</li> </ol> <p>Code for Phase 2 can be found <a href="https://github.com/SciRuby/rubyplot/pull/45/files/36497cc3fdb6b9eddaee51777509d1f388a8ba4a..f918e9c9f390cfa96e453f3db610eeaa8f3acbed">here</a> and <a href="https://github.com/SciRuby/rubyplot/pull/52/files/21d2450229ce8508f8a906914fd4bf47e1c62fa3..5947c911d290f34a09effca5ce3e866519b8c5db">here</a>.</p> <h2 id="phase-3">Phase 3</h2> <p>During Phase 3, I integrated Rubyplot with the IRuby notebooks which allow the user to draw figures inside the notebook just by using the <code class="language-plaintext highlighter-rouge">show</code> function, through this integration the user can quickly and easily test the code step by step before running the whole codebase.<br/> I also implemented ticks for ImageMagick backend.<br/> Finally, I created a tutorial for the library which also contains template codes for all the plots which a user can easily get familiar with the working of the library and start using it.</p> <p>So, during Phase 3, I completed the following deliverables -</p> <ol> <li>Integrated Rubyplot with IRuby notebooks with the support for inline plotting.</li> <li>Implemented and tested ticks for Magick backend.</li> <li>Created the tutorial for Rubyplot.</li> </ol> <p>Code for Phase 3 can be found <a href="https://github.com/SciRuby/rubyplot/pull/52/files/ca2aa7397581eaf92b64522361e3565f032e6250..3624962d8f96e3611c6bbc55a5c2c8aa1a299e27">here</a>.</p> <h1 id="resourcesblogs-code-etc">Resources(blogs, code, etc.)</h1> <h2 id="previous-work">Previous Work</h2> <ul> <li>GSoC 2018 project GRRuby by Pranav Garg can be found <a href="https://github.com/pgtgrly/GRruby-extension">here</a></li> <li>GSoC 2018 project Ruby Matplotlib by Arafat Dad Khan can be found <a href="https://github.com/Arafatk/magick-rubyplot">here</a></li> <li>A talk on Rubyplot by Pranav Garg in RubyConf 2018 can be found <a href="https://youtu.be/7QBkckZ1aNQ">here</a></li> </ul> <h2 id="my-work">My work</h2> <ul> <li>Daily updates can be found <a href="https://discourse.ruby-data.org/t/gsoc-2019-project-rubyplot-discussion/57">here</a></li> <li>Proposal can be found <a href="https://github.com/alishdipani/rubyplot/wiki/GSoC-2019-Proposal">here</a></li> <li>Tutorial notebook can be found <a href="https://github.com/alishdipani/rubyplot/blob/master/tutorial/magick/Rubyplot_Tutorial(Magick).ipynb">here</a> and can be viewed online(rendered) <a href="https://nbviewer.jupyter.org/github/alishdipani/rubyplot/blob/master/tutorial/magick/Rubyplot_Tutorial%28Magick%29.ipynb">here</a></li> <li>Rubyplot Github Repository can be found <a href="https://github.com/SciRuby/rubyplot">here</a></li> <li>All my work can be found in these PRs: <a href="https://github.com/SciRuby/rubyplot/pull/45">PR#45</a> and <a href="https://github.com/SciRuby/rubyplot/pull/52">PR#52</a></li> <li>Other blogs can be found here: <ol> <li><a href="https://alishdipani.github.io/gsoc2019/2019/06/08/GSoC-2019-project-introduction/">GSoC 2019 project introduction</a></li> <li><a href="https://alishdipani.github.io/gsoc2019/2019/06/09/Rubyplot-installation-guide/">Rubyplot installation guide</a></li> <li><a href="https://alishdipani.github.io/gsoc2019/2019/06/10/The-Scatter-plot-example/">The Scatter plot example</a></li> <li><a href="https://alishdipani.github.io/gsoc2019/2019/06/28/Simple-Plots-in-Rubyplot/">Simple Plots in Rubyplot</a></li> <li><a href="https://alishdipani.github.io/gsoc2019/2019/07/13/Multi-plots-in-Rubyplot/">Multi plots in Rubyplot</a></li> <li><a href="https://alishdipani.github.io/gsoc2019/2019/07/26/The-show-and-the-plot-functions/">The show and the plot functions</a></li> <li><a href="https://alishdipani.github.io/gsoc2019/2019/08/22/IRuby-integration-and-ticks/">IRuby integration and ticks</a></li> </ol> </li> </ul> <h1 id="future-work">Future Work</h1> <p>I plan to keep contributing to Rubyplot and also start contributing to other projects of SciRuby.<br/> Future work to be done for Rubyplot is to write documentation, add more tests, add more types of plots, add more backends, make the plots interactive and in future add the feature for plotting 3-Dimensional graphs which would also be interactive.</p> <h1 id="endnote">EndNote</h1> <p>With this, we come to an end of GSoC 2019. These 3 months have been very challenging, interesting, exciting and fun. I got to learn a lot of things while working on Rubyplot and while interacting with my mentors. I have experienced an improvement in my Software development skills and programming in general which will help me a lot in future. I would love to keep working with SciRuby on more such interesting projects and maybe even try for GSoC again next year ;)</p> <h1 id="acknowledgements">Acknowledgements</h1> <p>I would like to express my gratitude to my mentor Sameer Deshmukh for his guidance and support. He was always available and had solutions to every problem I faced, I got to learn a lot from him and I hope to learn a lot more from him in the future. I could not have asked for a better mentor.</p> <p>I would also like to thank Pranav Garg who introduced me to Ruby and also to the SciRuby community. During his GSoC 2018 project, he introduced me to the Rubyplot library and helped me get started with it. His suggestions were very helpful during my GSoC 2019 project.</p> <p>I would also like to thank mentors from SciRuby Prasun Anand and Shekhar Prasad Rajak for mentoring me and organising the occasional meetings and code reviews. I would also like to thank Udit Gulati for his helpful insights during the code reviews.</p> <p>I am grateful to Google and the Ruby Science Foundation for this golden opportunity.</p>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: The final blog for GSoC 2019.]]></summary></entry><entry><title type="html">The show and the plot functions</title><link href="https://alishdipani.github.io/gsoc2019/2019/07/26/The-show-and-the-plot-functions/" rel="alternate" type="text/html" title="The show and the plot functions"/><published>2019-07-26T12:00:00+00:00</published><updated>2019-07-26T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/07/26/The-show-and-the-plot-functions</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/07/26/The-show-and-the-plot-functions/"><![CDATA[<p>Summary: Multi plots in Rubyplot.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#show" id="markdown-toc-show">show</a> <ul> <li><a href="#device" id="markdown-toc-device">Device</a></li> <li><a href="#backend-functions" id="markdown-toc-backend-functions">Backend functions</a> <ul> <li><a href="#init_output_device" id="markdown-toc-init_output_device">init_output_device</a> <ul> <li><a href="#gr" id="markdown-toc-gr">GR</a></li> <li><a href="#magick" id="markdown-toc-magick">Magick</a></li> </ul> </li> <li><a href="#write-and-show" id="markdown-toc-write-and-show">write and show</a> <ul> <li><a href="#gr-1" id="markdown-toc-gr-1">GR</a></li> <li><a href="#magick-1" id="markdown-toc-magick-1">Magick</a></li> </ul> </li> <li><a href="#stop_output_device" id="markdown-toc-stop_output_device">stop_output_device</a> <ul> <li><a href="#gr-2" id="markdown-toc-gr-2">GR</a></li> <li><a href="#magick-2" id="markdown-toc-magick-2">Magick</a></li> </ul> </li> </ul> </li> </ul> </li> <li><a href="#plot" id="markdown-toc-plot">plot</a> <ul> <li><a href="#fmt-argument" id="markdown-toc-fmt-argument">fmt argument</a></li> <li><a href="#draw" id="markdown-toc-draw">draw</a></li> <li><a href="#examples" id="markdown-toc-examples">Examples</a> <ul> <li><a href="#1" id="markdown-toc-1">1</a></li> <li><a href="#2" id="markdown-toc-2">2</a></li> <li><a href="#3" id="markdown-toc-3">3</a></li> </ul> </li> </ul> </li> </ul> <h1 id="introduction">Introduction</h1> <p>This blog explains the working of the show and the plot functions and highlights the work done in Week 7 and 8 for GSoC 2019.</p> <h1 id="show">show</h1> <p>The <strong>show</strong> function is an alternative to the write function which is called on the <code class="language-plaintext highlighter-rouge">Rubyplot::Figure</code> object i.e. the Figure or the Canvas, it draws the figure which is stored temporarily and is shown in a pop-up window. This is used for a quick view of the Figure and helps in debugging.</p> <p>Usage of this function is same as <strong>write</strong> function, suppose <code class="language-plaintext highlighter-rouge">figure = Rubyplot::Figure.new</code> then <strong>write</strong> function is called as <code class="language-plaintext highlighter-rouge">figure.write(filename.png')</code>, similarly the <strong>show</strong> function is called as <code class="language-plaintext highlighter-rouge">figure.show</code>. It takes no input.</p> <p>The <strong>write</strong> and the <strong>show</strong> functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_height</span> <span class="o">=</span> <span class="vi">@height</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_width</span> <span class="o">=</span> <span class="vi">@width</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">figure</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">init_output_device</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span> <span class="p">}</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">write</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">stop_output_device</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">show</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_height</span> <span class="o">=</span> <span class="vi">@height</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_width</span> <span class="o">=</span> <span class="vi">@width</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">figure</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">init_output_device</span><span class="p">(</span><span class="kp">nil</span><span class="p">,</span> <span class="ss">device: :window</span><span class="p">)</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span> <span class="p">}</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">show</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">stop_output_device</span>
<span class="k">end</span>
</code></pre></div></div> <p>The only difference between both the functions is that the initialization is done differently i.e. <strong>init_output_device</strong> backend function, for <strong>show</strong> function there is no file name and hence <code class="language-plaintext highlighter-rouge">nil</code> is given and the device is <code class="language-plaintext highlighter-rouge">:window</code>, for the <strong>write</strong> function the device is <code class="language-plaintext highlighter-rouge">:file</code>. The main difference is that backend functions called are different.</p> <h2 id="device">Device</h2> <p>The <code class="language-plaintext highlighter-rouge">device</code> argument and backend variable(<code class="language-plaintext highlighter-rouge">output_device</code>) represent the device on which the Figure is to be drawn. The types are:</p> <ol> <li><code class="language-plaintext highlighter-rouge">:window</code> which represents a pop-up window on which the Figure will be shown for the <strong>show</strong> function.</li> <li><code class="language-plaintext highlighter-rouge">:file</code> which represents a file on which the Figure will be saved for the <strong>write</strong> function.</li> </ol> <h2 id="backend-functions">Backend functions</h2> <p>The important backend functions which needed to be updated for <strong>show</strong> function are <strong>init_output_device</strong>, <strong>show</strong> and <strong>stop_output_device</strong>. These functions are explained below:</p> <h3 id="init_output_device">init_output_device</h3> <p>This function is used to initialize the Figure and itâ€™s properties, for each backend, the functions are:</p> <h4 id="gr">GR</h4> <p>The function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">init_output_device</span> <span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="n">file_name</span>
  <span class="vi">@output_device</span> <span class="o">=</span> <span class="n">device</span>
  <span class="no">Rubyplot</span><span class="o">::</span><span class="no">GR</span><span class="p">.</span><span class="nf">clearws</span>

  <span class="no">Rubyplot</span><span class="o">::</span><span class="no">GR</span><span class="p">.</span><span class="nf">beginprint</span><span class="p">(</span><span class="vi">@file_name</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@output_device</span> <span class="o">==</span> <span class="ss">:file</span>
<span class="k">end</span>
</code></pre></div></div> <p>The file name and the output device are stored and then the workspace i.e. the Figure or the Canvas is cleared and finally, the printing (i.e. writing) is started if the device is <code class="language-plaintext highlighter-rouge">:file</code> i.e. when the <strong>write</strong> function is called.</p> <h4 id="magick">Magick</h4> <p>The function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">init_output_device</span> <span class="n">file_name</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">device: :file</span>
  <span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span> <span class="o">=</span> <span class="n">scale_figure</span><span class="p">(</span><span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span><span class="p">)</span>
  <span class="vi">@draw</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">if</span> <span class="vi">@base_image</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="n">top_color</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">theme_options</span><span class="p">[</span><span class="ss">:background_colors</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">bottom_color</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">theme_options</span><span class="p">[</span><span class="ss">:background_colors</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">theme_options</span><span class="p">[</span><span class="ss">:background_direction</span><span class="p">]</span>

    <span class="vi">@base_image</span> <span class="o">=</span> <span class="n">render_gradient</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span><span class="p">,</span> <span class="n">direction</span>
  <span class="k">else</span>
    <span class="vi">@base_image</span><span class="p">.</span><span class="nf">erase!</span>
  <span class="k">end</span>
  <span class="vi">@output_device</span> <span class="o">=</span> <span class="n">device</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="n">file_name</span> <span class="k">if</span> <span class="vi">@output_device</span> <span class="o">==</span> <span class="ss">:file</span>
<span class="k">end</span>
</code></pre></div></div> <p>For consistency between the backends, the <strong>setup_background_graient</strong> function was merged into this function.<br/> So, first, the Figure dimensions are scaled according to the unit of the dimensions. Then the <code class="language-plaintext highlighter-rouge">Magick::Draw</code> objects are initialized for drawing. Then, if the <code class="language-plaintext highlighter-rouge">base_image</code> is already not initialized, it is created by calling the <strong>render_gradient</strong>, otherwise, it is just cleared. Finally, the output device is stored. The file name is stored only if the device is <code class="language-plaintext highlighter-rouge">:file</code> i.e. when the <strong>write</strong> function is called.</p> <h3 id="write-and-show">write and show</h3> <p>Both these functions have the same task to draw everything on the Figure and hence they are similar:</p> <h4 id="gr-1">GR</h4> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write</span>
  <span class="n">draw</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">show</span>
  <span class="n">draw</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">draw</span>
  <span class="n">draw_axes</span>
<span class="k">end</span>
</code></pre></div></div> <p>For GR backend, these functions only draw the X and the Y axes y calling the <strong>draw</strong> function which calls the <strong>draw_axes</strong> function. The remaining drawing will be done later.</p> <h4 id="magick-1">Magick</h4> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write</span>
  <span class="vi">@draw</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="vi">@text</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="n">draw_axes</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">show</span>
  <span class="vi">@draw</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="vi">@text</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="n">draw_axes</span>
<span class="k">end</span>
</code></pre></div></div> <p>For Magick backend, first the plot is drawn, then the text and finally the X and the Y axes.</p> <h3 id="stop_output_device">stop_output_device</h3> <p>This function is used to finish the drawing and clear the memory.</p> <h4 id="gr-2">GR</h4> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stop_output_device</span>
  <span class="k">case</span> <span class="vi">@output_device</span>
  <span class="k">when</span> <span class="ss">:file</span>
    <span class="no">Rubyplot</span><span class="o">::</span><span class="no">GR</span><span class="p">.</span><span class="nf">endprint</span>
  <span class="k">when</span> <span class="ss">:window</span>
    <span class="no">Rubyplot</span><span class="o">::</span><span class="no">GR</span><span class="p">.</span><span class="nf">updatews</span>
  <span class="k">end</span>
  <span class="n">flush</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">flush</span>
  <span class="vi">@axes_map</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div> <p>For GR backend, depending on the output device different functions are called to finish the drawing. If <strong>write</strong> function was called i.e. output device is <code class="language-plaintext highlighter-rouge">:file</code> then <code class="language-plaintext highlighter-rouge">Rubyplot::GR.endprint</code> is called to end the printing i.e. saving of the Figure. Otherwise, if the <strong>show</strong> function was called i.e. output device is <code class="language-plaintext highlighter-rouge">:window</code> the <code class="language-plaintext highlighter-rouge">Rubyplot::GR.updatews</code>(which calls the GR inbuilt function <code class="language-plaintext highlighter-rouge">updatews()</code>) is called which updates the workspace and opens a pop-up window to show the completed Figure.<br/> Finally, the <strong>flush</strong> function is called which clears the memory.</p> <h4 id="magick-2">Magick</h4> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stop_output_device</span>
  <span class="k">case</span> <span class="vi">@output_device</span>
  <span class="k">when</span> <span class="ss">:file</span>
    <span class="vi">@base_image</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="vi">@file_name</span><span class="p">)</span>
  <span class="k">when</span> <span class="ss">:window</span>
    <span class="vi">@base_image</span><span class="p">.</span><span class="nf">display</span>
  <span class="k">end</span>
  <span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span> <span class="o">=</span> <span class="n">unscale_figure</span><span class="p">(</span><span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span><span class="p">)</span>
  <span class="n">flush</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">flush</span>
  <span class="vi">@axes_map</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div> <p>Similar to the GR backend, depending on the output device, different inbuilt ImageMagick functions are called. If <strong>write</strong> function was called i.e. the output device is <code class="language-plaintext highlighter-rouge">:file</code> then <strong>write</strong> inbuilt function is called which saves i.e. writes the Figure in a file. Otherwise, if the <strong>show</strong> function was called i.e. the output device is <code class="language-plaintext highlighter-rouge">:window</code> then <strong>display</strong> function is called which displays the completed Figure on a pop-up window.<br/> Finally, the <strong>flush</strong> function is called and the memory is cleared.</p> <h1 id="plot">plot</h1> <p>In the current state, Line and Scatter plots exist as two different kinds of plots. However, the crux of plotting both of these is the same, the only difference being that in one kind of plot we have straight lines connected to co-ordinates while in the other the co-ordinates are simply â€˜decoratedâ€™. Thus can be many combinations of these plots, which can be combined under a single â€˜plotâ€™ interface.</p> <p>So, to combine these plots, the <strong>plot</strong> function is created which is considered a <code class="language-plaintext highlighter-rouge">BasicPlot</code> in Rubyplot. It is called just like the other plots i.e. scatter plot, line plot, etc. The plot function can draw both scatter plot and line plot even simultaneously.</p> <p>The inputs taken are the label of the plot(<code class="language-plaintext highlighter-rouge">label</code>), the optional type, size, fill colour and border colour of the marker(<code class="language-plaintext highlighter-rouge">marker_type</code>, <code class="language-plaintext highlighter-rouge">marker_size</code>, <code class="language-plaintext highlighter-rouge">marker_fill_color</code>, <code class="language-plaintext highlighter-rouge">marker_border_color</code> respectively), the optional type, colour, width, opacity of the line(<code class="language-plaintext highlighter-rouge">line_type</code>, <code class="language-plaintext highlighter-rouge">line_color</code>, <code class="language-plaintext highlighter-rouge">line_width</code>, <code class="language-plaintext highlighter-rouge">line_opacity</code> respectively), and the <code class="language-plaintext highlighter-rouge">fmt</code> argument which specifies the colour, line type and marker type in short.</p> <h2 id="fmt-argument">fmt argument</h2> <p>Inspired by matplotlib, the fmt argument is a string of characters representing the colours in the plot, the type of the marker and the line.<br/> The characters for colour are:</p> <table> <thead> <tr> <th>characters</th> <th style="text-align: center">colour</th> </tr> </thead> <tbody> <tr> <td>b</td> <td style="text-align: center">blue</td> </tr> <tr> <td>g</td> <td style="text-align: center">green</td> </tr> <tr> <td>r</td> <td style="text-align: center">red</td> </tr> <tr> <td>c</td> <td style="text-align: center">cyan</td> </tr> <tr> <td>m</td> <td style="text-align: center">magenta</td> </tr> <tr> <td>y</td> <td style="text-align: center">yellow</td> </tr> <tr> <td>k</td> <td style="text-align: center">black</td> </tr> <tr> <td>w</td> <td style="text-align: center">white</td> </tr> </tbody> </table> <p>The characters for marker types are:</p> <table> <thead> <tr> <th>characters</th> <th style="text-align: center">marker type</th> </tr> </thead> <tbody> <tr> <td>.</td> <td style="text-align: center">dot</td> </tr> <tr> <td>,</td> <td style="text-align: center">omark</td> </tr> <tr> <td>o</td> <td style="text-align: center">circle</td> </tr> <tr> <td>v</td> <td style="text-align: center">traingle_down</td> </tr> <tr> <td>^</td> <td style="text-align: center">traingle_up</td> </tr> <tr> <td>&lt;</td> <td style="text-align: center">solid_tri_left</td> </tr> <tr> <td>&gt;</td> <td style="text-align: center">solid_tri_right</td> </tr> <tr> <td>1</td> <td style="text-align: center">solid_triangle_down</td> </tr> <tr> <td>2</td> <td style="text-align: center">solid_triangle_up</td> </tr> <tr> <td>3</td> <td style="text-align: center">solid_tri_left</td> </tr> <tr> <td>4</td> <td style="text-align: center">solid_tri_right</td> </tr> <tr> <td>s</td> <td style="text-align: center">square</td> </tr> <tr> <td>p</td> <td style="text-align: center">pentagon</td> </tr> <tr> <td>*</td> <td style="text-align: center">star</td> </tr> <tr> <td>h</td> <td style="text-align: center">hexagon</td> </tr> <tr> <td>H</td> <td style="text-align: center">heptagon</td> </tr> <tr> <td>+</td> <td style="text-align: center">plus</td> </tr> <tr> <td>x</td> <td style="text-align: center">diagonal_cross</td> </tr> <tr> <td>D</td> <td style="text-align: center">solid_diamond</td> </tr> <tr> <td>d</td> <td style="text-align: center">diamond</td> </tr> <tr> <td>|</td> <td style="text-align: center">vline</td> </tr> <tr> <td>_</td> <td style="text-align: center">hline</td> </tr> </tbody> </table> <p>The characters for line types are:</p> <table> <thead> <tr> <th>characters</th> <th style="text-align: center">line type</th> </tr> </thead> <tbody> <tr> <td>â€“(two consecutive -)</td> <td style="text-align: center">dashed</td> </tr> <tr> <td>-.</td> <td style="text-align: center">dashed_dotted</td> </tr> <tr> <td>-</td> <td style="text-align: center">solid</td> </tr> <tr> <td>:</td> <td style="text-align: center">dotted</td> </tr> </tbody> </table> <p>The fmt argument detects the characters and sets the corresponding variables, possibly overwriting them. The characters can be in any order. The colour of the fmt sets every colour to the given input i.e. the marker fill colour, marker border colour and the line colour.<br/> To set the variables, a hash having characters as keys and symbol as the value is iterated over the keys checking that the character is present in the string or not. The code for taking the fmt argument as input is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">COLOR_TYPES_FMT</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">'b'</span> <span class="o">=&gt;</span> <span class="ss">:blue</span><span class="p">,</span>
  <span class="s1">'g'</span> <span class="o">=&gt;</span> <span class="ss">:green</span><span class="p">,</span>
  <span class="s1">'r'</span> <span class="o">=&gt;</span> <span class="ss">:red</span><span class="p">,</span>
  <span class="s1">'c'</span> <span class="o">=&gt;</span> <span class="ss">:cyan</span><span class="p">,</span>
  <span class="s1">'m'</span> <span class="o">=&gt;</span> <span class="ss">:magenta</span><span class="p">,</span>
  <span class="s1">'y'</span> <span class="o">=&gt;</span> <span class="ss">:yellow</span><span class="p">,</span>
  <span class="s1">'k'</span> <span class="o">=&gt;</span> <span class="ss">:black</span><span class="p">,</span>
  <span class="s1">'w'</span> <span class="o">=&gt;</span> <span class="ss">:white</span>
<span class="p">}.</span><span class="nf">freeze</span>

<span class="no">MARKER_TYPES_FMT</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">'.'</span> <span class="o">=&gt;</span> <span class="ss">:dot</span><span class="p">,</span>
  <span class="s1">','</span> <span class="o">=&gt;</span> <span class="ss">:omark</span><span class="p">,</span>
  <span class="s1">'o'</span> <span class="o">=&gt;</span> <span class="ss">:circle</span><span class="p">,</span>
  <span class="s1">'v'</span> <span class="o">=&gt;</span> <span class="ss">:traingle_down</span><span class="p">,</span>
  <span class="s1">'^'</span> <span class="o">=&gt;</span> <span class="ss">:traingle_up</span><span class="p">,</span>
  <span class="s1">'&lt;'</span> <span class="o">=&gt;</span> <span class="ss">:solid_tri_left</span><span class="p">,</span>
  <span class="s1">'&gt;'</span> <span class="o">=&gt;</span> <span class="ss">:solid_tri_right</span><span class="p">,</span>
  <span class="s1">'1'</span> <span class="o">=&gt;</span> <span class="ss">:solid_triangle_down</span><span class="p">,</span>
  <span class="s1">'2'</span> <span class="o">=&gt;</span> <span class="ss">:solid_triangle_up</span><span class="p">,</span>
  <span class="s1">'3'</span> <span class="o">=&gt;</span> <span class="ss">:solid_tri_left</span><span class="p">,</span>
  <span class="s1">'4'</span> <span class="o">=&gt;</span> <span class="ss">:solid_tri_right</span><span class="p">,</span>
  <span class="s1">'s'</span> <span class="o">=&gt;</span> <span class="ss">:square</span><span class="p">,</span>
  <span class="s1">'p'</span> <span class="o">=&gt;</span> <span class="ss">:pentagon</span><span class="p">,</span>
  <span class="s1">'*'</span> <span class="o">=&gt;</span> <span class="ss">:star</span><span class="p">,</span>
  <span class="s1">'h'</span> <span class="o">=&gt;</span> <span class="ss">:hexagon</span><span class="p">,</span>
  <span class="s1">'H'</span> <span class="o">=&gt;</span> <span class="ss">:heptagon</span><span class="p">,</span>
  <span class="s1">'+'</span> <span class="o">=&gt;</span> <span class="ss">:plus</span><span class="p">,</span>
  <span class="s1">'x'</span> <span class="o">=&gt;</span> <span class="ss">:diagonal_cross</span><span class="p">,</span>
  <span class="s1">'D'</span> <span class="o">=&gt;</span> <span class="ss">:solid_diamond</span><span class="p">,</span>
  <span class="s1">'d'</span> <span class="o">=&gt;</span> <span class="ss">:diamond</span><span class="p">,</span>
  <span class="s1">'|'</span> <span class="o">=&gt;</span> <span class="ss">:vline</span><span class="p">,</span>
  <span class="s1">'_'</span> <span class="o">=&gt;</span> <span class="ss">:hline</span>
<span class="p">}.</span><span class="nf">freeze</span>

<span class="no">LINE_TYPES_FMT</span> <span class="o">=</span><span class="p">{</span>
  <span class="s1">'--'</span> <span class="o">=&gt;</span> <span class="ss">:dashed</span><span class="p">,</span>
  <span class="s1">'-.'</span> <span class="o">=&gt;</span> <span class="ss">:dashed_dotted</span><span class="p">,</span>
  <span class="s1">'-'</span> <span class="o">=&gt;</span> <span class="ss">:solid</span><span class="p">,</span>
  <span class="s1">':'</span> <span class="o">=&gt;</span> <span class="ss">:dotted</span>
<span class="p">}.</span><span class="nf">freeze</span>

<span class="k">def</span> <span class="nf">fmt</span><span class="o">=</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">fmt</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">String</span>
    <span class="k">raise</span> <span class="no">TypeError</span><span class="p">,</span> <span class="s1">'fmt argument takes a String input'</span>
  <span class="k">end</span>

  <span class="no">COLOR_TYPES_FMT</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">symbol</span><span class="p">,</span> <span class="n">color</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">fmt</span><span class="p">.</span><span class="nf">include?</span> <span class="n">symbol</span>
      <span class="vi">@marker_fill_color</span> <span class="o">=</span> <span class="n">color</span>
      <span class="vi">@marker_border_color</span> <span class="o">=</span> <span class="n">color</span>
      <span class="vi">@line_color</span> <span class="o">=</span> <span class="n">color</span>
      <span class="k">break</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="no">LINE_TYPES_FMT</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">symbol</span><span class="p">,</span> <span class="n">line_type</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">fmt</span><span class="p">.</span><span class="nf">include?</span> <span class="n">symbol</span>
      <span class="vi">@line_type</span> <span class="o">=</span> <span class="n">line_type</span>
      <span class="k">break</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="no">MARKER_TYPES_FMT</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">symbol</span><span class="p">,</span> <span class="n">marker_type</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">fmt</span><span class="p">.</span><span class="nf">include?</span> <span class="n">symbol</span>
      <span class="vi">@marker_type</span> <span class="o">=</span> <span class="n">marker_type</span>
      <span class="k">break</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>First, the type of the fmt argument is checked, then the hashes are iterated over for colour, marker type and line type. As soon as a character is matched, the iteration stops. The symbols in line type hash are stored in priority of detection i.e. <code class="language-plaintext highlighter-rouge">--</code> and <code class="language-plaintext highlighter-rouge">-.</code> are checked before <code class="language-plaintext highlighter-rouge">-</code> so that <code class="language-plaintext highlighter-rouge">-.</code> and <code class="language-plaintext highlighter-rouge">--</code> are not mistaken for <code class="language-plaintext highlighter-rouge">-</code>.</p> <p>After setting all the properties of the plot, the <strong>draw</strong> function is called.</p> <h2 id="draw">draw</h2> <p>The draw function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="c1"># Default marker fill color</span>
  <span class="vi">@marker_fill_color</span> <span class="o">=</span> <span class="ss">:default</span> <span class="k">if</span> <span class="vi">@marker_fill_color</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="c1"># defualt type of plot is solid line</span>
  <span class="vi">@line_type</span> <span class="o">=</span> <span class="ss">:solid</span> <span class="k">if</span> <span class="vi">@line_type</span><span class="p">.</span><span class="nf">nil?</span> <span class="o">&amp;&amp;</span> <span class="vi">@marker_type</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Line2D</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">x: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">],</span>
    <span class="ss">y: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">],</span>
    <span class="ss">type: </span><span class="vi">@line_type</span><span class="p">,</span>
    <span class="c1"># type: line_style[1].to_sym,</span>
    <span class="ss">color: </span><span class="vi">@line_color</span><span class="p">,</span>
    <span class="ss">opacity: </span><span class="vi">@line_opacity</span><span class="p">,</span>
    <span class="ss">width: </span><span class="vi">@line_width</span>
  <span class="p">).</span><span class="nf">draw</span> <span class="k">if</span> <span class="vi">@line_type</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_markers</span><span class="p">(</span>
    <span class="ss">x: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">],</span>
    <span class="ss">y: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">],</span>
    <span class="ss">type: </span><span class="vi">@marker_type</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@marker_fill_color</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@marker_border_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="p">[</span><span class="vi">@marker_size</span><span class="p">]</span> <span class="o">*</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">size</span>
  <span class="p">)</span> <span class="k">if</span> <span class="vi">@marker_type</span>
<span class="k">end</span>
</code></pre></div></div> <p>First the marker fill colour is set to default if it is not specified by the user, then if none of the marker type or line type is specified then the line type is set to solid and marker type is <code class="language-plaintext highlighter-rouge">nil</code> i.e. the default plot type is solid line.<br/> Finally, if the line type is given then a <code class="language-plaintext highlighter-rouge">Line2D</code> object is created and drawn and if the marker type is given then the <strong>draw_markers</strong> backend function is called to draw the markers.</p> <p>Some examples of the plot function are given below.</p> <h2 id="examples">Examples</h2> <h3 id="1">1</h3> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">height: </span><span class="mi">40</span><span class="p">,</span> <span class="ss">width: </span><span class="mi">40</span><span class="p">,</span> <span class="ss">figsize_unit: :cm</span><span class="p">)</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">plot!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:plus</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">line_type</span> <span class="o">=</span> <span class="ss">:solid</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">360</span><span class="p">).</span><span class="nf">step</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="no">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Simple sine wave plot."</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'plot1.png'</span><span class="p">)</span>
</code></pre></div></div> <p>Backend: Magick</p> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/The_show_and_the_plot_functions/plot1.png" width="600"/></p> <h3 id="2">2</h3> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">height: </span><span class="mi">40</span><span class="p">,</span> <span class="ss">width: </span><span class="mi">40</span><span class="p">,</span> <span class="ss">figsize_unit: :cm</span><span class="p">)</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">plot!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">line_type</span> <span class="o">=</span> <span class="ss">:solid</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">fmt</span> <span class="o">=</span> <span class="s1">'y-.'</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">360</span><span class="p">).</span><span class="nf">step</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nf">to_a</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="no">Math</span><span class="p">.</span><span class="nf">sin</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="no">Math</span><span class="o">::</span><span class="no">PI</span> <span class="o">/</span> <span class="mi">180</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Simple sine wave plot."</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'plot2.png'</span><span class="p">)</span>
</code></pre></div></div> <p>Backend: GR<br/> Here, the fmt argument sets the colour and overwrites the line type.</p> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/The_show_and_the_plot_functions/plot2.png" width="600"/></p> <h3 id="3">3</h3> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">height: </span><span class="mi">80</span><span class="p">,</span> <span class="ss">width: </span><span class="mi">80</span><span class="p">)</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">plot!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">fmt</span> <span class="o">=</span> <span class="s1">'rD'</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">150</span><span class="p">).</span><span class="nf">to_a</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="o">..</span><span class="mi">50</span><span class="p">).</span><span class="nf">to_a</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"simple plot with dots."</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'plot3.png'</span><span class="p">)</span>
</code></pre></div></div> <p>Backend: Magick</p> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/The_show_and_the_plot_functions/plot3.png" width="600"/></p>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: Multi plots in Rubyplot.]]></summary></entry><entry><title type="html">Multi plots in Rubyplot</title><link href="https://alishdipani.github.io/gsoc2019/2019/07/13/Multi-plots-in-Rubyplot/" rel="alternate" type="text/html" title="Multi plots in Rubyplot"/><published>2019-07-13T12:00:00+00:00</published><updated>2019-07-13T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/07/13/Multi-plots-in-Rubyplot</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/07/13/Multi-plots-in-Rubyplot/"><![CDATA[<p>Summary: Multi plots in Rubyplot.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#multi-bar-plot" id="markdown-toc-multi-bar-plot">Multi Bar plot</a></li> <li><a href="#multi-box-plot" id="markdown-toc-multi-box-plot">Multi Box plot</a></li> <li><a href="#multi-candle-stick-plot" id="markdown-toc-multi-candle-stick-plot">Multi Candle-stick plot</a></li> <li><a href="#multi-stacked-bar-plot" id="markdown-toc-multi-stacked-bar-plot">Multi Stacked-bar plot</a></li> </ul> <h1 id="introduction">Introduction</h1> <p>This blog lists down the Multi plots in Rubyplot with ImageMagick as backend and highlights the work done in Week 5 and 6 for GSoC 2019.</p> <p>Multi plots are plots which combine multiple plots of the same kind in the same subplot i.e. the same <code class="language-plaintext highlighter-rouge">axes</code> object. In Rubyplot, even if one plot is specified, it is considered as a multi plot i.e. a single bar plot is considered as multi bar plot.<br/> P.S. - The version of Rubyplot used in this blog is dated 13th July.</p> <h1 id="multi-bar-plot">Multi Bar plot</h1> <h1 id="multi-box-plot">Multi Box plot</h1> <h1 id="multi-candle-stick-plot">Multi Candle-stick plot</h1> <h1 id="multi-stacked-bar-plot">Multi Stacked-bar plot</h1>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: Multi plots in Rubyplot.]]></summary></entry><entry><title type="html">Simple Plots in Rubyplot</title><link href="https://alishdipani.github.io/gsoc2019/2019/06/28/Simple-Plots-in-Rubyplot/" rel="alternate" type="text/html" title="Simple Plots in Rubyplot"/><published>2019-06-28T12:00:00+00:00</published><updated>2019-06-28T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/06/28/Simple-Plots-in-Rubyplot</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/06/28/Simple-Plots-in-Rubyplot/"><![CDATA[<p>Summary: Simple plots in Rubyplot.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#scatter-plot" id="markdown-toc-scatter-plot">Scatter plot</a></li> <li><a href="#area-plot" id="markdown-toc-area-plot">Area plot</a></li> <li><a href="#bar-plot" id="markdown-toc-bar-plot">Bar plot</a></li> <li><a href="#bubble-plot" id="markdown-toc-bubble-plot">Bubble plot</a></li> <li><a href="#candle-stick-plot" id="markdown-toc-candle-stick-plot">Candle-stick plot</a></li> <li><a href="#histogram" id="markdown-toc-histogram">Histogram</a></li> <li><a href="#line-plot" id="markdown-toc-line-plot">Line plot</a></li> <li><a href="#error-bar-plot" id="markdown-toc-error-bar-plot">Error-bar plot</a></li> <li><a href="#box-plot" id="markdown-toc-box-plot">Box plot</a></li> </ul> <h1 id="introduction">Introduction</h1> <p>This blog lists down the simple plots in Rubyplot with ImageMagick as backend and highlights the work done in Week 3 and 4 for GSoC 2019.<br/> P.S. - The version of Rubyplot used in this blog is dated 28th June.</p> <h1 id="scatter-plot">Scatter plot</h1> <p>An example of Scatter plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@x1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="vi">@y1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">65</span><span class="p">]</span>
<span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">scatter!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_size</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:diagonal_cross</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Scatter plot"</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_title</span> <span class="o">=</span> <span class="s2">"X data"</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_title</span> <span class="o">=</span> <span class="s2">"Y data"</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'scatterplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/scatterplot.png" width="600"/></p> <p>The scatter plot draws markers at the position specified by the user, the inputs taken are the X and Y coordinates for the markers (<code class="language-plaintext highlighter-rouge">data</code>), the label(<code class="language-plaintext highlighter-rouge">label</code>) for this plot, size of the marker (<code class="language-plaintext highlighter-rouge">marker_size</code>), type of the marker (<code class="language-plaintext highlighter-rouge">marker_type</code>), colour of the border of the marker (<code class="language-plaintext highlighter-rouge">marker_border_color</code>) and colour to be filled inside the marker (<code class="language-plaintext highlighter-rouge">marker_fill_color</code>).<br/> If the marker does not have a fill colour (example - plus, diagonal cross, dot) then the fill colour is set as the colour of the colour of the marker.</p> <p><strong>draw</strong> function for scatter plot is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="vi">@marker_fill_color</span> <span class="o">=</span> <span class="ss">:default</span> <span class="k">if</span> <span class="vi">@marker_fill_color</span><span class="p">.</span><span class="nf">nil?</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_markers</span><span class="p">(</span>
    <span class="ss">x: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">],</span>
    <span class="ss">y: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">],</span>
    <span class="ss">type: </span><span class="vi">@marker_type</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@marker_fill_color</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@marker_border_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="p">[</span><span class="vi">@marker_size</span><span class="p">]</span> <span class="o">*</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">size</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here, first the marker fill colour is set to default colour if it is <code class="language-plaintext highlighter-rouge">nil</code> the the <strong>draw_markers</strong> function is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_markers</span><span class="p">(</span><span class="n">x</span><span class="p">:,</span> <span class="n">y</span><span class="p">:,</span> <span class="ss">type: :default</span><span class="p">,</span> <span class="ss">fill_color: :default</span><span class="p">,</span> <span class="ss">border_color: :default</span><span class="p">,</span> <span class="ss">size: </span><span class="kp">nil</span><span class="p">)</span>
  <span class="n">y</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">iy</span><span class="p">,</span> <span class="n">idx_y</span><span class="o">|</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x</span><span class="p">[</span><span class="n">idx_y</span><span class="p">],</span><span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">iy</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="c1"># in GR backend size is multiplied by</span>
    <span class="c1"># nominal size generated on the graphics device</span>
    <span class="c1"># so set the nominal_factor to 15</span>
    <span class="n">within_window</span> <span class="k">do</span>
      <span class="n">size</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">*=</span> <span class="no">NOMINAL_FACTOR_MARKERS</span>
      <span class="no">MARKER_TYPES</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="nf">call</span><span class="p">(</span><span class="vi">@draw</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">[</span><span class="n">idx_y</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>The coordinates are first transformed, then the size of the marker is multiplied by a nominal factor (hardcoded to 15) to match the marker sizes in GR backend as GR backend multiplies its marker sizes by a nominal factor which is not mentioned.<br/> To draw the markers, a hash is used which has lambdas for drawing different types of markers, an example of the hash is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MARKER_TYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1"># Default type is circle</span>
  <span class="c1"># Stroke width is set to 1</span>
  <span class="ss">default: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">circle: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">plus: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1"># size is length of one line</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">line</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="c1"># Rest of the code omitted due to space constraint</span>
<span class="p">}</span>
</code></pre></div></div> <p>Each of these lambdas take the properties of the marker and draw it depending on the type of marker, for example the <code class="language-plaintext highlighter-rouge">circle</code> type draws a circle with size as its radius, the <code class="language-plaintext highlighter-rouge">plus</code> type draws two perpendicular lines in the shape of a plus sign (+) with the size as length of the lines.<br/> A hash of lambdas is used instead of making a module or a class to avoid inconsistencies in backends as GR does not require functions for creating marker types and only requires the type of the marker, i.e. its internal functions take care of drawing the marker types. Also, generally Hashes are much faster than functions and hence hashes are preferred over a module or a class.</p> <p>Marker types implemented till now for ImageMagick bacckend are: circle, plus, dot, diagonal_cross, solid_circle, traingle_down, solid_traingle_down, traingle_up, solid_traingle_up, square, solid_square, bowtie, solid_bowtie, hglass, solid_hglass, diamond, solid_diamond, solid_tri_right, solid_tri_left, hollow_plus, solid_plus, vline, hline, omark.</p> <p>Marker types not yet implemented for ImageMagick backend are: star, solid_star, asterisk, tri_up_down, pentagon, hexagon, heptagon, octagon, star_4, star_5, star_6, star_7, star_8.</p> <h1 id="area-plot">Area plot</h1> <p>An example of Area plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">area!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">86</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">88</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"Jimmy"</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Area plot"</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'areaplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/areaplot.png" width="600"/></p> <p>The area plot draws a line passing through the points given as the input and colours the area covered under this line.<br/> The inputs taken are the data as a compulsory array containing Y coordinate values of the points and an optional array containing X coordinate values of the points(<code class="language-plaintext highlighter-rouge">data</code>), the label of the plot(<code class="language-plaintext highlighter-rouge">label</code>) and the color of the plot(<code class="language-plaintext highlighter-rouge">color</code>).</p> <p>If only one set of values is given to the area plot as the data, for example only [30, 36, 86, 39, 27, 31, 79, 88] is given then this set is considered as a set of Y coordinates of the points and X coordinates are set as 0, 1, 2 â€¦ (size of y values - 1) i.e. the coordinates are (0, 30), (1, 36), (2, 86), (3, 39), (4, 27), (5, 31), (6, 79), (7, 88).</p> <p>Now, this is the list of coordinates through which the line has to pass and the area under the curve is to be filled, but to draw this a polygon is needed in which the colour will be filled. TO create this polygon, we just need to append the starting point and end point of the X axis so that the polygon is completed. So, here in the example taken above the starting point of X axis is (minimum x value, minimum y value) i.e. (0, 27) and the end point of X axis is (maximum x value, minimum y value) i.e. (7, 27).<br/> So, finally the coordinates for the polygon are (0, 30), (1, 36), (2, 86), (3, 39), (4, 27), (5, 31), (6, 79), (7, 88), (0, 27), (7, 27).<br/> The code for appending these points is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x_poly_points</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">concat</span><span class="p">([</span><span class="vi">@axes</span><span class="p">.</span><span class="nf">x_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">,</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">x_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">])</span>
<span class="n">y_poly_points</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">].</span><span class="nf">concat</span><span class="p">([</span><span class="vi">@axes</span><span class="p">.</span><span class="nf">y_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">,</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">y_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">])</span>
</code></pre></div></div> <p>The opacity of the polygon i.e. the area under the curve is set to <strong>0.3</strong> to make the areas behind an area visible.<br/> After this, a <code class="language-plaintext highlighter-rouge">Rubyplot::Artist::Polygon</code> object is created whhich uses the <code class="language-plaintext highlighter-rouge">draw_polygon</code> backend function to draw the polygon, the <code class="language-plaintext highlighter-rouge">draw_polygon</code> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_polygon</span><span class="p">(</span><span class="n">x</span><span class="p">:,</span> <span class="n">y</span><span class="p">:,</span> <span class="n">border_width</span><span class="p">:,</span> <span class="n">border_type</span><span class="p">:,</span> <span class="n">border_color</span><span class="p">:,</span> <span class="n">fill_color</span><span class="p">:,</span>
  <span class="n">fill_opacity</span><span class="p">:)</span>
  <span class="n">within_window</span> <span class="k">do</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="n">ix</span><span class="o">|</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">ix</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="n">iy</span><span class="o">|</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">iy</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">zip</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke_width</span> <span class="n">border_width</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="n">fill_opacity</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">polygon</span> <span class="o">*</span><span class="n">coords</span><span class="p">.</span><span class="nf">flatten</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Thsi function first transforms the coordiantes and then combines the coordiantes which were two different sets before (x values = [0, 1, 2, 3, 4, 5, 6, 7, 0, 7] and y values = [30, 36, 86, 39, 27, 31, 79, 88, 27, 27]), the <code class="language-plaintext highlighter-rouge">zip</code> Ruby function is used to combine the points (now coords = [[0, 30], [1, 36], [2, 86], [3, 39], [4, 27], [5, 31], [6, 79], [7, 88], [0, 27], [7, 27]]). After this the properties of the polygon are set and the coordinates are given as an input to the polygon function of rmagick, but first the coordiantes array is flattened (now coords = [0, 30, 1, 36, 2, 86, 3, 39, 4, 27, 5, 31, 6, 79, 7, 88, 0, 27, 7, 27]) so that input is converted into the way that polygon function accepts, the splat operator (*) is used to give the coords array as an argument to the function. Finally, the opacity of <code class="language-plaintext highlighter-rouge">Magick::Draw</code> object is set again to 1 (initial value).</p> <h1 id="bar-plot">Bar plot</h1> <p>An example of Bar plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">bar!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:neon_red</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Bar plot"</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'barplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/barplot.png" width="600"/></p> <p>The bar plot draws bars which are rectangles with heights as the data given as the input.<br/> Th inputs taken are the color of the bars(<code class="language-plaintext highlighter-rouge">color</code>), the label of the plot(<code class="language-plaintext highlighter-rouge">label</code>), the data which is a single array for the sizes of the bars representing the Y values of the bars(<code class="language-plaintext highlighter-rouge">data</code>) and the space between the bars as a ratio(<code class="language-plaintext highlighter-rouge">spacing_ratio</code>) i.e. the range is [0,1] where 0 represents no space between the bars and 1 represents maximum space between the bars which is equivalent to the maximum space alloted to a bar i.e. (total X range / number of bars).<br/> The X values for the coordinates are set as 0,1,â€¦number of Y values i.e. in this example when the data is given as [5,12,9,6,7], the coordinates for the bars are (0,5), (1,12), (2,9), (3,6) and (4,7) respectively.</p> <p>Now, the bars are rectangles which are stored in the <code class="language-plaintext highlighter-rouge">rectangles</code> array, the X and Y coordinates of lower left corner of these rectangles are stored in <code class="language-plaintext highlighter-rouge">abs_x_left</code> and <code class="language-plaintext highlighter-rouge">abs_y_left</code> respectively. The upper right corner coordinates are calculated by adding the width of the bar to the X coordinate of the lower left corner and seeting the Y coordinate to the height of the bar as set in the <code class="language-plaintext highlighter-rouge">data</code> by the user.<br/> This is done when <strong>draw</strong> is called which calls the <strong>setup_bar_rectangles</strong> function:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="n">setup_bar_rectangles</span>
  <span class="vi">@rectangles</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">setup_bar_rectangles</span>
<span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">].</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">iy</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
  <span class="vi">@rectangles</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Rectangle</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">x1: </span><span class="vi">@abs_x_left</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
    <span class="ss">y1: </span><span class="vi">@abs_y_left</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
    <span class="ss">x2: </span><span class="vi">@abs_x_left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="vi">@bar_width</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="n">iy</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:color</span><span class="p">],</span>
    <span class="ss">fill_color: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:color</span><span class="p">]</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This calculation of <code class="language-plaintext highlighter-rouge">abs_x_left</code> and <code class="language-plaintext highlighter-rouge">abs_y_left</code> is done by the multibars code which will be explained in the next blog.</p> <p>The <strong>draw</strong> function of the <code class="language-plaintext highlighter-rouge">Ractangle</code> object is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_rectangle</span><span class="p">(</span>
    <span class="ss">x1: </span><span class="vi">@x1</span><span class="p">,</span>
    <span class="ss">y1: </span><span class="vi">@y1</span><span class="p">,</span>
    <span class="ss">x2: </span><span class="vi">@x2</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="vi">@y2</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@border_color</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@fill_color</span><span class="p">,</span>
    <span class="ss">abs: </span><span class="vi">@abs</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>It calls the <strong>draw_rectangle</strong> backend function and passes the information about the rectangle:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_rectangle</span><span class="p">(</span><span class="n">x1</span><span class="p">:,</span><span class="n">y1</span><span class="p">:,</span><span class="n">x2</span><span class="p">:,</span><span class="n">y2</span><span class="p">:,</span> <span class="ss">border_color: :default</span><span class="p">,</span>
  <span class="ss">fill_color: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">border_width: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">border_type: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
  <span class="n">within_window</span><span class="p">(</span><span class="n">abs</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x1</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x2</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y1</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y2</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>

    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span> <span class="k">if</span> <span class="n">fill_color</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke_width</span> <span class="n">border_width</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="c1"># if fill_color is not given, the rectangle fill colour is transparent</span>
    <span class="c1"># i.e. only edges are visible</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="mi">0</span> <span class="k">unless</span> <span class="n">fill_color</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">rectangle</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="mi">1</span> <span class="k">unless</span> <span class="n">fill_color</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here, first the coordinates are transformed and then the properties of the rectangle are set and if <code class="language-plaintext highlighter-rouge">fill_color</code> is not given then a hollow rectangle is drawn by setting the <code class="language-plaintext highlighter-rouge">fill_opacity</code> to 0. Finally, <code class="language-plaintext highlighter-rouge">Magick::Draw</code>â€™s <strong>rectangle</strong> function is used to draw the rectangle. If the fill_color is not given then the <code class="language-plaintext highlighter-rouge">fill_opacity</code> is reset to 1.</p> <h1 id="bubble-plot">Bubble plot</h1> <p>An example of Bubble plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">bubble!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"apples"</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:blue</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"simple bubble plot."</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'bubbleplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/bubbleplot.png" width="600"/></p> <p>The bubble plot draws circles with the size and the coordinates as specified by the user.<br/> The inputs taken are the data which consists of three arrays for X coordinates, Y coordinates and the sizes of the bubbles respectively(<code class="language-plaintext highlighter-rouge">data</code>), the label of the plot(<code class="language-plaintext highlighter-rouge">label</code>) and the color of the bubbles(<code class="language-plaintext highlighter-rouge">color</code>).</p> <p>In this example the X,Y coordinates and sizes for the bubbles respectively are (-1, -35), size = 4.5; (19 21), size = 1.0; (-4, 23), size = 2.1; (-23, -4), size = 0.9. The <strong>draw</strong> function creates and draws the <code class="language-plaintext highlighter-rouge">Circle</code> objects for the bubbles:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">idx</span><span class="o">|</span>
    <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Circle</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="nb">self</span><span class="p">,</span>
      <span class="ss">x: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
      <span class="ss">y: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
      <span class="ss">radius: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:z_values</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span>
      <span class="ss">fill_opacity: </span><span class="mf">0.5</span><span class="p">,</span>
      <span class="ss">color: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:color</span><span class="p">],</span>
      <span class="ss">border_width: </span><span class="mi">1</span><span class="p">,</span>
      <span class="ss">abs: </span><span class="kp">false</span>
    <span class="p">).</span><span class="nf">draw</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here, for bubble plot, the border width of the circles is set to 1 pixel. The opacity of the circles is hardcoded to <strong>0.5</strong> for visibility of overlapping bubbles.<br/> P.S. - Later, the opacity of the bubble will be taken as an optional input(<code class="language-plaintext highlighter-rouge">fill_opacity</code>) with the default value set to <strong>0.5</strong>.</p> <p>The <strong>draw</strong> function for the <code class="language-plaintext highlighter-rouge">Circle</code> object is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_circle</span><span class="p">(</span>
    <span class="ss">x: </span><span class="vi">@x</span><span class="p">,</span>
    <span class="ss">y: </span><span class="vi">@y</span><span class="p">,</span>
    <span class="ss">radius: </span><span class="vi">@radius</span><span class="p">,</span>
    <span class="ss">border_type: :solid</span><span class="p">,</span>
    <span class="ss">border_width: </span><span class="vi">@border_width</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">fill_opacity: </span><span class="vi">@fill_opacity</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>It calls the backend function <strong>draw_circle</strong> and passes the information about the circle:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_circle</span><span class="p">(</span><span class="n">x</span><span class="p">:,</span> <span class="n">y</span><span class="p">:,</span> <span class="n">radius</span><span class="p">:,</span> <span class="ss">border_type: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">border_width: </span><span class="mf">1.0</span><span class="p">,</span> <span class="ss">fill_color: </span><span class="kp">nil</span><span class="p">,</span>
  <span class="ss">border_color: :default</span><span class="p">,</span> <span class="ss">fill_opacity: </span><span class="mf">0.0</span><span class="p">)</span>
  <span class="n">within_window</span> <span class="k">do</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">transform_x</span> <span class="ss">x: </span><span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">transform_y</span> <span class="ss">y: </span><span class="n">y</span>

    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke_width</span> <span class="n">border_width</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span> <span class="k">if</span> <span class="n">fill_color</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="n">fill_opacity</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="no">NOMINAL_FACTOR_CIRCLE</span><span class="p">),</span><span class="n">y</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>First the coordinates are transformed, then the properties of the circle are set and finally the <code class="language-plaintext highlighter-rouge">Magick::Draw</code>â€™s <strong>circle</strong> function is called to draw the circle.<br/> Here the radius of the circle is multiplied by a nominal factor in order to match the Magick backend and GR backend sizes. The nominal factor <code class="language-plaintext highlighter-rouge">NOMINAL_FACTOR_CIRCLE</code> is hardcoded to <strong>27.5</strong>.</p> <h1 id="candle-stick-plot">Candle-stick plot</h1> <p>An example of Candle-stick plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">candle_stick!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">lows</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">110</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">highs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">140</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">170</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">150</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">opens</span> <span class="o">=</span> <span class="p">[</span><span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">120</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">closes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">130</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">160</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">140</span><span class="p">]</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Simple candle stick plot."</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'candlestickplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/candlestickplot.png" width="600"/></p> <p>The candle-stick plot draws rectangles i.e. bars (candle) with a line (stick) passing through the center of the rectangles parallel to the Y axis.<br/> The inputs taken are arrays for lower Y coordinate of the rectangles(<code class="language-plaintext highlighter-rouge">opens</code>) and upper Y coordinate of the rectangles(<code class="language-plaintext highlighter-rouge">closes</code>), arrays for lower Y coordinate of the lines(<code class="language-plaintext highlighter-rouge">lows</code>) and the upper Y coordinate of the lines(<code class="language-plaintext highlighter-rouge">highs</code>), the colour of the rectangles(<code class="language-plaintext highlighter-rouge">color</code>), width of the rectangles(<code class="language-plaintext highlighter-rouge">bar_width</code>), the label of the plot(<code class="language-plaintext highlighter-rouge">label</code>) and the color of the border of the bars(<code class="language-plaintext highlighter-rouge">border_color</code>).</p> <p>The X coordinates of the lower left corner of the bar and the line are stored in <code class="language-plaintext highlighter-rouge">x_left_candle</code> and <code class="language-plaintext highlighter-rouge">x_low_stick</code> respectively. The <strong>draw</strong> function calculates the remaining dimensions (similar to the Bar plot) of the lines and rectangles and creates and draws the <code class="language-plaintext highlighter-rouge">Line2D</code> and <code class="language-plaintext highlighter-rouge">Rectangle</code> objects for lines and rectangles respectively:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
 <span class="vi">@x_low_stick</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">ix_stick</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
   <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Line2D</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
     <span class="nb">self</span><span class="p">,</span>
     <span class="ss">x: </span><span class="p">[</span><span class="n">ix_stick</span><span class="p">,</span> <span class="n">ix_stick</span><span class="p">],</span>
     <span class="ss">y: </span><span class="p">[</span><span class="vi">@lows</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="vi">@highs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
   <span class="p">).</span><span class="nf">draw</span>
 <span class="k">end</span>
 
 <span class="vi">@x_left_candle</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">ix_candle</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
   <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Rectangle</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
     <span class="nb">self</span><span class="p">,</span>
     <span class="ss">x1: </span><span class="n">ix_candle</span><span class="p">,</span>
     <span class="ss">y1: </span><span class="vi">@opens</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
     <span class="ss">x2: </span><span class="n">ix_candle</span> <span class="o">+</span> <span class="vi">@bar_width</span><span class="p">,</span>
     <span class="ss">y2: </span><span class="vi">@closes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
     <span class="ss">border_color: </span><span class="vi">@border_color</span><span class="p">,</span>
     <span class="ss">fill_color: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:color</span><span class="p">]</span>
   <span class="p">).</span><span class="nf">draw</span>
 <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">x_left_candle</code> and <code class="language-plaintext highlighter-rouge">x_low_stick</code> are calculated using the multi_candle_stick code which will be explained in the next blog.</p> <p>The <code class="language-plaintext highlighter-rouge">Rectangle</code> object is explained previously. For, the line(stick), a <code class="language-plaintext highlighter-rouge">Line2D</code> object is created and drawn with default colour which is black. The <code class="language-plaintext highlighter-rouge">Line2D</code> object is a straight line between two points. The <strong>draw</strong> function for <code class="language-plaintext highlighter-rouge">Line2D</code> is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_lines</span><span class="p">(</span><span class="ss">x: </span><span class="vi">@x</span><span class="p">,</span> <span class="ss">y: </span><span class="vi">@y</span><span class="p">,</span>
    <span class="ss">width: </span><span class="vi">@width</span><span class="p">,</span> <span class="ss">color: </span><span class="vi">@color</span><span class="p">,</span> <span class="ss">opacity: </span><span class="vi">@opacity</span><span class="p">,</span> <span class="ss">type: </span><span class="vi">@type</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This passes the properties of the line to the backend function <strong>draw_lines</strong>, which is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_lines</span><span class="p">(</span><span class="n">x</span><span class="p">:,</span> <span class="n">y</span><span class="p">:,</span> <span class="ss">width: </span><span class="mf">2.0</span><span class="p">,</span> <span class="ss">type: :default</span><span class="p">,</span> <span class="ss">color: :default</span><span class="p">,</span> <span class="ss">opacity: </span><span class="mf">1.0</span><span class="p">)</span>
  <span class="n">within_window</span> <span class="k">do</span>
    <span class="n">y</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">_</span><span class="p">,</span> <span class="n">idx_y</span><span class="o">|</span>
      <span class="k">if</span> <span class="n">idx_y</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">y</span><span class="p">.</span><span class="nf">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x</span><span class="p">[</span><span class="n">idx_y</span><span class="p">],</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y</span><span class="p">[</span><span class="n">idx_y</span><span class="p">],</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x</span><span class="p">[</span><span class="n">idx_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y</span><span class="p">[</span><span class="n">idx_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
        <span class="no">LINE_TYPES</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="nf">call</span><span class="p">(</span><span class="vi">@draw</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">opacity</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>It iterates over the array of X values and Y values and draws straight lines between the consecutive points i.e. the current point and the point stored in the next index of the arrays. After transforming the points, based on the line type, the values are passed to a hash of lambdas(just like scatter plot markers) for drawinf the line. The hash is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">LINE_TYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1"># Default type is solid</span>
  <span class="ss">default: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">opacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="n">opacity</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke_width</span> <span class="n">width</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">line</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span>
  <span class="p">},</span>
  <span class="ss">solid: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">opacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="n">opacity</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke_width</span> <span class="n">width</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">line</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span>
  <span class="p">},</span>
  <span class="ss">dashed: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">opacity</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">raise</span> <span class="no">NotImplementedError</span><span class="p">,</span> <span class="s1">'This line has not yet been implemented'</span>
  <span class="p">}</span>
  <span class="c1"># Rest of the code omitted due to space constraint</span>
<span class="p">}</span>
</code></pre></div></div> <p>Each of these lambdas take the properties of the lines and draw it.</p> <p>The line types available are solid, dashed, dotted, dashed_dotted, dash_2_dot, dash_3_dot, long_dash, long_short_dash, spaced_dash, spaced_dot, double_dot and triple dot. The default type of line is solid.<br/> Till now, only solid line type is implemented for Magick backend, rest all will be implemented soon.</p> <p>Hence, the <code class="language-plaintext highlighter-rouge">Rectangle</code> and <code class="language-plaintext highlighter-rouge">Line2D</code> objects are drawn which are the candle and the stick respectively.</p> <h1 id="histogram">Histogram</h1> <p>An example of Histogram with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">histogram!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span><span class="p">{</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'histogram.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/histogram.png" width="600"/></p> <p>Histogram draws rectangles(bars) which represent the frequency of a label(i.e. an object, a range of numbers, etc.)<br/> The inputs taken are the color of the bars(<code class="language-plaintext highlighter-rouge">color</code>), the label of the plot(<code class="language-plaintext highlighter-rouge">label</code>), width of the bars(<code class="language-plaintext highlighter-rouge">bar_width</code>), an array of numbers as the data(<code class="language-plaintext highlighter-rouge">x</code>), an optional number representing number of bins or an array of increasing numbers representing bins over which the frequency will be calculated(<code class="language-plaintext highlighter-rouge">bins</code>).</p> <p>So, bins can be set in three ways:</p> <ol> <li>If bins are not specified i.e. not given as an input then number of bins are set as number of unique numbers in the data, here in the example(assuming each number from 0 to 9 is present) the number of bins will be 10. The subdivisions(Integer) is calculated which is the difference maximum value and minimum value in data divided by the number of bins. So, here in the example subdivisions = (9-0)/10 = 0.9 = 0 (as subdivisions is an Integer).<br/> Then the bins array is set as an array having numbers starting from the minimum value in the data added with subdivisions over and over again until the maximum value in the data and finally the largest unique number added with ubdivisions is appended to the bins array. So, the bins array is [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] and hence the bins are 0-1, 1-2, 2-3, 3-4, 4-5, 5-6, 6-7, 7-8, 8-9 and 9-10. The bins are inclusive of the starting number.</li> <li>If bins are given as the number of bins i.e. an Integer representing the number of bins then similarly to case 1, the bins are calculated.</li> <li>If bins are given directly i.e. an array is given.<br/> Example - [1,4,7,10] then the bins will be [1,4), [4,7), [7,10] i.e. the startig value is included and the ending value is excluded unless itâ€™s the end of values i.e. bins array.</li> </ol> <p>After calculating the bins, the combined frequencies of the bins are calculated which are the heights of the bars for each bin. Hence, the <code class="language-plaintext highlighter-rouge">Rectangle</code> objects are drawn(as explained previously) with each bar representing a bin and the height representing the frequency of the bin.</p> <h1 id="line-plot">Line plot</h1> <p>An example of Line plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">line!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"Marco"</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:blue</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"A line graph."</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'lineplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/lineplot.png" width="600"/></p> <p>The Line plot draws a line between consecutive points specified by the user and thus draws a line passing through the points taken as input.<br/> The input taken by the Line plot are type of the line(<code class="language-plaintext highlighter-rouge">line_type</code>), width of the line(<code class="language-plaintext highlighter-rouge">line_width</code>), the color of the line(<code class="language-plaintext highlighter-rouge">line_color</code>) and the data having a compulsory array having Y coordinate values for the points and an optional array having X coordinate values(<code class="language-plaintext highlighter-rouge">data</code>) and the label of the plot(<code class="language-plaintext highlighter-rouge">label</code>).</p> <p>If only one array is given to the line plot as the data then the X coordinate values are calculated as 0,1,2â€¦(number of Y - 1) values. This is similar to the Area plot.</p> <p>The <strong>draw</strong> function calls the <strong>draw_lines</strong> backend function to create the lines, which is as explained before and hence the Line plot is drawn.</p> <h1 id="error-bar-plot">Error-bar plot</h1> <p>An example of Error-bar plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Simple error bar plot with collection xerr and yerr."</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">error_bar!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">xerr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.3</span><span class="p">]</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">yerr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mf">0.1</span><span class="p">]</span>
<span class="k">end</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'errorbarplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/errorbarplot.png" width="600"/></p> <p>Error-bar plot draws a line plot for the data taken and draws lines for errors at the given points.<br/> The inputs taken are two arrays for X coordinate values and Y coordinate values respectively(<code class="language-plaintext highlighter-rouge">data</code>), label of the plot(<code class="language-plaintext highlighter-rouge">label</code>), colour of the line and the error lines(<code class="language-plaintext highlighter-rouge">color</code>), an array for X error values(<code class="language-plaintext highlighter-rouge">xerr</code>) and an array for Y error values(<code class="language-plaintext highlighter-rouge">yerr</code>).</p> <p>The line and the errors are all <code class="language-plaintext highlighter-rouge">Line2D</code> objects which are explained previously. The coordinates for the error lines are calculated by adding and subtraicting the error to the coordinates i.e. suppose at the first point (1,1) the X error is 0.5 then the X error line will be between the points (0.5,1) and (0.5,1) and similarly the Y error is 0.6 then the Y error line is between the points (1,0.4) and (1,1.6).</p> <h1 id="box-plot">Box plot</h1> <p>An example of Box plot with code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"A simple box plot."</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">box_plot!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span>
    <span class="p">[</span><span class="mi">60</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">50</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">70</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
  <span class="p">]</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_title</span> <span class="o">=</span> <span class="s2">"foo"</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_title</span> <span class="o">=</span> <span class="s2">"bar"</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s1">'boxplot.png'</span><span class="p">)</span>
</code></pre></div></div> <p><img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/Simple_Plots_in_Rubyplot/boxplot.png" width="600"/></p> <p>The box plot will be explained in the next blog in the multi box plot section.</p>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: Simple plots in Rubyplot.]]></summary></entry><entry><title type="html">The Scatter plot example</title><link href="https://alishdipani.github.io/gsoc2019/2019/06/10/The-Scatter-plot-example/" rel="alternate" type="text/html" title="The Scatter plot example"/><published>2019-06-10T12:00:00+00:00</published><updated>2019-06-10T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/06/10/The-Scatter-plot-example</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/06/10/The-Scatter-plot-example/"><![CDATA[<p>Summary: Explaining the scatter plot example.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#the-example-code" id="markdown-toc-the-example-code">The Example code</a></li> <li><a href="#an-overview" id="markdown-toc-an-overview">An overview</a></li> <li><a href="#code-explanation" id="markdown-toc-code-explanation">Code Explanation</a> <ul> <li><a href="#figure" id="markdown-toc-figure">Figure</a></li> <li><a href="#adding-a-subplot" id="markdown-toc-adding-a-subplot">Adding a subplot</a> <ul> <li><a href="#axes" id="markdown-toc-axes">Axes</a> <ul> <li><a href="#x-axis-and-y-axis" id="markdown-toc-x-axis-and-y-axis">X Axis and Y axis</a></li> </ul> </li> </ul> </li> <li><a href="#the-plot" id="markdown-toc-the-plot">The Plot</a> <ul> <li><a href="#scatter-plot" id="markdown-toc-scatter-plot">Scatter Plot</a> <ul> <li><a href="#the-block-properties-of-the-scatter-plot" id="markdown-toc-the-block-properties-of-the-scatter-plot">The Block (properties of the scatter plot)</a></li> </ul> </li> </ul> </li> <li><a href="#axes-properties-properties-of-the-subplot" id="markdown-toc-axes-properties-properties-of-the-subplot">Axes properties (properties of the subplot)</a></li> <li><a href="#writing-figure" id="markdown-toc-writing-figure">Writing Figure</a> <ul> <li><a href="#initializing-the-backend" id="markdown-toc-initializing-the-backend">Initializing the backend</a></li> <li><a href="#setting-up-the-background-gradient-creating-the-figure" id="markdown-toc-setting-up-the-background-gradient-creating-the-figure">Setting up the background gradient (creating the Figure)</a></li> <li><a href="#setting-up-the-output-device" id="markdown-toc-setting-up-the-output-device">Setting up the Output device</a></li> <li><a href="#processing-the-data-in-subplots" id="markdown-toc-processing-the-data-in-subplots">Processing the data in subplots</a></li> <li><a href="#drawing-the-subplots" id="markdown-toc-drawing-the-subplots">Drawing the Subplots</a> <ul> <li><a href="#legend-box" id="markdown-toc-legend-box">Legend Box</a></li> </ul> </li> <li><a href="#x-and-y-ticks" id="markdown-toc-x-and-y-ticks">X and Y ticks</a></li> <li><a href="#x-axis-and-y-axis-1" id="markdown-toc-x-axis-and-y-axis-1">X axis and Y axis</a></li> <li><a href="#drawing-plots" id="markdown-toc-drawing-plots">Drawing plots</a></li> <li><a href="#writing-figure-backend" id="markdown-toc-writing-figure-backend">Writing Figure (Backend)</a></li> </ul> </li> <li><a href="#finishing-up" id="markdown-toc-finishing-up">Finishing up</a></li> </ul> </li> </ul> <h1 id="introduction">Introduction</h1> <p>In the project introduction blog <a href="https://alishdipani.github.io/gsoc2019/2019/06/09/GSoC-2019-project-introduction/">[Link]</a> a scatter plot example was given, I will be explaining the technical details for that example which involves explaining the code for the library using <strong>Magick backend</strong>.</p> <p><strong>P.S. - This blog is targeted towards new developers who want to get familiar with the codebase of the library or anyone who is extremely interested in technical code details as this blog is very technical and requires some familiarity with Rubyplot and rmagick.</strong><br/> P.S. - The version of the library used for this example is of date 9 June.</p> <h1 id="the-example-code">The Example code</h1> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'Rubyplot'</span>
<span class="vi">@xdata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1"># Defining X data</span>
<span class="vi">@ydata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">65</span><span class="p">]</span> <span class="c1"># Defining Y data</span>
<span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># Creating the canvas</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="c1"># Adding a subplot (0,0 as only one subplot is to be plotted)</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">scatter!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="c1"># Setting scatter as the type of subplot</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Nice plot"</span> <span class="c1"># defining title of the plot</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_title</span> <span class="o">=</span> <span class="s2">"X data"</span> <span class="c1"># defining title of X axis</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_title</span> <span class="o">=</span> <span class="s2">"Y data"</span> <span class="c1"># defining title of Y axis</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"scatterplot.png"</span><span class="p">)</span> <span class="c1"># Drawing the figure and saving it</span>
</code></pre></div></div> <p>The output using Magick backend is:<br/> <img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/GSoC_2019_project_introduction/scatter_Magick.png" width="600"/></p> <h1 id="an-overview">An overview</h1> <p>An overview of how the code works is that it first creates the canvas(figure) on which everything will be drawn, then the space for subplots is created in this figure and then the subplots are added. When a subplot is added, the type of the subplot (i.e. the plots in this particular subplot), the properties of the subplot, the data for the plots in this subplot, the title for the X axis, Y axis and the subplot itself etc. are defined. After setting the properties of all the subplots, the write function is called to actually draw and save the figure. During drawing everything is drawn including the Legendbox of the subplots.</p> <p>So, creating any figure in Rubyplot can be broken down into these steps:</p> <ol> <li>Create the Figure with desired properties.</li> <li>Define the number of subplots desired and thus the space for these subplots is created.</li> <li>Create the subplots one by one and set the desired properties of all the subplots.</li> <li>Call the <code class="language-plaintext highlighter-rouge">write</code> function to actually draw the Figure and thus the desired figure is created, drawn and saved.</li> </ol> <h1 id="code-explanation">Code Explanation</h1> <p>So to go through the code letâ€™s start with the first 3 lines</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'Rubyplot'</span>
<span class="vi">@xdata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1"># Defining X data</span>
<span class="vi">@ydata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">65</span><span class="p">]</span> <span class="c1"># Defining Y data</span>
</code></pre></div></div> <p>First Rubyplot is included which is similar to import in Python, this allows us to use Rubyplot. Next, we define 2 arrays <em>xdata</em> and <em>ydata</em> which store the X and Y coordinates to be plotted. So, the points to be plotted are (1,11), (2,2), (3,33), (4,4) and (5,65).</p> <h2 id="figure">Figure</h2> <p>After this, we create a new Figure object which will act as the canvas on which image will be drawn.</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># Creating the canvas</span>
</code></pre></div></div> <p>Creating a figure object calls the constructor of the figure class.</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="ss">height: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">width: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">figsize_unit: :cm</span><span class="p">)</span>
    <span class="k">super</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s1">''</span>
    <span class="vi">@nrows</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="vi">@ncols</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="vi">@width</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">||</span> <span class="no">DEFAULT_CANVAS_DIM</span><span class="p">).</span><span class="nf">to_f</span>
    <span class="vi">@height</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">||</span> <span class="no">DEFAULT_CANVAS_DIM</span><span class="p">).</span><span class="nf">to_f</span>
    <span class="vi">@top_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@bottom_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@left_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@right_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@subplots</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="vi">@figsize_unit</span> <span class="o">=</span> <span class="n">figsize_unit</span>
    <span class="n">set_rubyplot_artist_coords!</span>
    <span class="n">setup_default_theme</span>
    <span class="n">add_subplots!</span> <span class="vi">@nrows</span><span class="p">,</span> <span class="vi">@ncols</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here, <em>height</em> and <em>width</em> represent the height and width of the canvas to be made respectively. <em>figsize_unit</em> is for saving the unit for measurement which are pixel, centimeter or inch (default is cm).<br/> Now, the Figure class inherits the Base class which initializes the origin for the figure in Rubyplot Coordinates which is set to 0,0.<br/> After this default values are given to the required variables which include <em>width</em> and <em>height</em> set at 40 cm, spacing variables are for the margin for the figure (in pixels), <em>nrows</em> and <em>ncols</em> are the number of rows and columns in which each (row, column) represents a subplot, <em>subplots</em> variable is a 2-D array for storing subplots(which are axes objects), <em>title</em> is the title of the figure. Now, the function <strong>set_rubyplot_artist_coords!</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_rubyplot_artist_coords!</span>
  <span class="vi">@max_x</span> <span class="o">=</span> <span class="mf">100.0</span>
  <span class="vi">@max_y</span> <span class="o">=</span> <span class="mf">100.0</span>
  <span class="vi">@min_x</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="vi">@min_y</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">if</span> <span class="vi">@height</span> <span class="o">&gt;</span> <span class="vi">@width</span>
    <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="vi">@height</span> <span class="o">/</span> <span class="vi">@width</span>
    <span class="vi">@max_y</span> <span class="o">=</span> <span class="vi">@max_y</span> <span class="o">*</span> <span class="n">aspect_ratio</span>
  <span class="k">elsif</span> <span class="vi">@height</span> <span class="o">&lt;</span> <span class="vi">@width</span>
    <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="vi">@width</span> <span class="o">/</span> <span class="vi">@height</span>
    <span class="vi">@max_x</span> <span class="o">=</span> <span class="vi">@max_x</span> <span class="o">*</span> <span class="n">aspect_ratio</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This sets the maximum and minimum coordinates for Rubyplot in Rubyplot coordinates and so the figure has an X and Y range as [0, max] for both X and Y coordinates in Rubyplot coordinates. Then this function defines the <em>aspect_ratio</em> and then changes the maximum value and the range for X or Y depending on the canvas height and width.</p> <p>After this, the function <strong>setup_default_theme</strong> is called which initializes some useful variables for the colour of the figure:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">setup_default_theme</span>
  <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">marker_color: :white</span><span class="p">,</span>
    <span class="ss">font_color: :black</span><span class="p">,</span>
    <span class="ss">background_image: </span><span class="kp">nil</span>
  <span class="p">}</span>
  <span class="vi">@theme_options</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">.</span><span class="nf">merge</span> <span class="no">Themes</span><span class="o">::</span><span class="no">CLASSIC_WHITE</span>
  <span class="vi">@marker_color</span> <span class="o">=</span> <span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:marker_color</span><span class="p">]</span>
  <span class="vi">@font_color</span> <span class="o">=</span> <span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:font_color</span><span class="p">]</span> <span class="o">||</span> <span class="vi">@marker_color</span>
<span class="k">end</span>
</code></pre></div></div> <p>First a <em>defaults</em> hash is defined which stores the default values of <em>marker_color</em> as the symbol <em>:white</em> which represents white colour, <em>font_color</em> as <em>:black</em> and <em>background_image</em> colour as nil. Then the empty <em>theme_options</em> hash is merged with a hash present in Themes module named <em>CLASSIC_WHITE</em>:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plain White background with no gradient.</span>
<span class="no">CLASSIC_WHITE</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">marker_color: </span><span class="s1">'black'</span><span class="p">,</span>
  <span class="ss">font_color: </span><span class="s1">'black'</span><span class="p">,</span>
  <span class="ss">background_colors: </span><span class="sx">%I[white white]</span><span class="p">,</span>
  <span class="ss">label_colors: </span><span class="sx">%I[strong_blue vivid_orange dark_lime_green strong_red slightly_desaturated_violet dark_grey strong_yellow strong_cyan yellow maroon grey]</span>
<span class="p">}.</span><span class="nf">freeze</span>
</code></pre></div></div> <p>This hash which is now equal to <em>theme_options</em> has default values and represents a White background with no gradient.<br/> After merging the values of <em>marker_color</em> and <em>theme_color</em> are set according to the <em>theme_options</em> hash defaults.</p> <p>Now the function <strong>add_subplots!</strong> is called which creates and initializes the <em>subplots</em> array:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_subplots!</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">)</span>
  <span class="vi">@nrows</span> <span class="o">=</span> <span class="n">nrows</span>
  <span class="vi">@ncols</span> <span class="o">=</span> <span class="n">ncols</span>
  <span class="vi">@subplots</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@nrows</span><span class="p">)</span> <span class="p">{</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@ncols</span><span class="p">)</span> <span class="p">{</span> <span class="kp">nil</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div> <p>The <em>subplots</em> array is of dimension <em>nrows</em> x <em>ncols</em>.</p> <h2 id="adding-a-subplot">Adding a subplot</h2> <p>After creating the figure, we move to adding subplots. To add a subplot the function <strong>add_subplot!</strong> is called</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
</code></pre></div></div> <p>But first, we need to call the function <strong>add_subplots!</strong> to create the space for subplots i.e. initialize the <em>subplots</em> array and define the number of subplots. In this example, 0,0 specifies that only 1 subplot is to be created and we have already created the space for it(during initialization of the Figure) and so we donâ€™t need to do it again.<br/> Now, the function <strong>add_subplot!</strong> is called for our figure object:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_subplot!</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
  <span class="n">plottable_width</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@max_x</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@left_spacing</span> <span class="o">+</span> <span class="vi">@right_spacing</span><span class="p">)).</span><span class="nf">to_f</span>
  <span class="n">plottable_length</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@max_y</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@top_spacing</span> <span class="o">+</span> <span class="vi">@bottom_spacing</span><span class="p">)).</span><span class="nf">to_f</span>
  <span class="vi">@subplots</span><span class="p">[</span><span class="n">nrow</span><span class="p">][</span><span class="n">ncol</span><span class="p">]</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Axes</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@left_spacing</span> <span class="o">+</span> <span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@ncols</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncol</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@bottom_spacing</span> <span class="o">+</span> <span class="p">(</span><span class="n">plottable_length</span> <span class="o">/</span> <span class="vi">@nrows</span><span class="p">)</span> <span class="o">*</span> <span class="n">nrow</span><span class="p">,</span>
    <span class="ss">width: </span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@ncols</span><span class="p">,</span>
    <span class="ss">height: </span><span class="n">plottable_length</span> <span class="o">/</span> <span class="vi">@nrows</span>
  <span class="p">)</span>
  <span class="vi">@subplots</span><span class="p">[</span><span class="n">nrow</span><span class="p">][</span><span class="n">ncol</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function takes input the row and coloumn for the subplot which is 1,1 in our case but is stored as 0,0 in the <em>subplots</em> array. First, <em>plottable_width</em> and <em>plottable_length</em> are calculated in Rubyplot coordinate units which define the total space measurements in which plotting is allowed i.e. incorporating the spacing for the figure. Then a new Axes object is made and is stored in the <em>subplots</em> array at the index 0,0. The function then returns the <em>subplots</em> array at index 0,0 which is stored in <em>axes</em> variable.</p> <h3 id="axes">Axes</h3> <p>Now the <em>axes</em> variable contains an initialized Axes object which is also stored in <em>subplots</em> array at index 0,0. The Axes initialization is as follows:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="n">abs_x</span><span class="p">:,</span> <span class="n">abs_y</span><span class="p">:,</span> <span class="n">width</span><span class="p">:,</span> <span class="n">height</span><span class="p">:)</span>
  <span class="vi">@figure</span> <span class="o">=</span> <span class="n">figure</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
  <span class="vi">@width</span> <span class="o">=</span> <span class="n">width</span>
  <span class="vi">@height</span> <span class="o">=</span> <span class="n">height</span>

  <span class="vi">@x_title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@y_title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@top_margin</span> <span class="o">=</span> <span class="mf">5.0</span>
  <span class="vi">@left_margin</span> <span class="o">=</span> <span class="mf">10.0</span>
  <span class="vi">@bottom_margin</span> <span class="o">=</span> <span class="mf">10.0</span>
  <span class="vi">@right_margin</span> <span class="o">=</span> <span class="mf">5.0</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@title_shift</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@title_margin</span> <span class="o">=</span> <span class="no">TITLE_MARGIN</span>
  <span class="vi">@text_font</span> <span class="o">=</span> <span class="ss">:default</span>
  <span class="vi">@grid</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="vi">@bounding_box</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="vi">@plots</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@raw_rows</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span><span class="o">/</span><span class="n">width</span><span class="p">)</span>
  <span class="vi">@theme</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Themes</span><span class="o">::</span><span class="no">CLASSIC_WHITE</span>
  <span class="vi">@font</span> <span class="o">=</span> <span class="ss">:times_roman</span>
  <span class="vi">@font_color</span> <span class="o">=</span> <span class="ss">:black</span>
  <span class="vi">@font_size</span> <span class="o">=</span> <span class="mf">15.0</span>
  <span class="vi">@legend_font_size</span> <span class="o">=</span> <span class="mf">20.0</span>
  <span class="vi">@legend_margin</span> <span class="o">=</span> <span class="no">LEGEND_MARGIN</span>
  <span class="vi">@title_font_size</span> <span class="o">=</span> <span class="mf">25.0</span>
  <span class="vi">@plot_colors</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@legends</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@lines</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@texts</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@x_axis</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">XAxis</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="vi">@y_axis</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">YAxis</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="vi">@legend_box_position</span> <span class="o">=</span> <span class="ss">:top</span>
<span class="k">end</span>
</code></pre></div></div> <p>The inputs are the figure to which this axes belongs which was given by self, axs_x and abs_y are the X and Y coordinate of this axesâ€™s lower left corner in Rubyplot coordinates and the <em>width</em> and <em>height</em> are the allowed space for this subplot i.e. the area in which this subplot is to be drawn.<br/> Other important variables initialized margin variables which define the margin for this subplot(axes object), <em>plots</em> array which stores the plots to be drawn in this subplot, <em>xaxis</em> and <em>yaxis</em> which are an object of <em>XAxis</em> and <em>YAxis</em> respectively.<br/> So, after initializing this axes object is stored in <em>axes</em> variable and <em>subplots</em> array at index 0,0.</p> <h4 id="x-axis-and-y-axis">X Axis and Y axis</h4> <p>We have initialized the variables <em>x_axis</em> and <em>y_axis</em> with new XAxis and YAxis objects, so when these objects are created, their constructor is called i.e. initialize function:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X Axis constructor</span>
<span class="k">def</span> <span class="nf">initialize</span> <span class="n">axes</span>
  <span class="k">super</span>
<span class="k">end</span>

<span class="c1"># Y axis constructor</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">super</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, both these classes inherit the Base of Axis and in the constructor of both of these classes, the constructor of Base is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span> <span class="n">axes</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@min_val</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@max_val</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@major_ticks_count</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="vi">@minor_ticks_count</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="vi">@texts</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@lines</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@major_ticks</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@minor_ticks</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@title_font_size</span> <span class="o">=</span> <span class="mf">25.0</span>
<span class="k">end</span>
</code></pre></div></div> <p>This constructor sets various useful properties of X and Y axes to their default values. It takes the axes object as an input to store it into <em>axes</em> variable to store the axes object to which it belongs, next the <em>title</em> is set to empty and the <em>max_val</em> and the <em>min_val</em> are stored to nil which store the maximum and minimum value of the X and the Y axes, next the number of major and minor ticks (between two major ticks) are stored, then two arrays are initialized <em>texts</em> and <em>lines</em> (not actually used) to store the texts and lines (tick lines not actual axis lines) for the X and Y axes, then the variables <em>major_ticks</em> and <em>minor_ticks</em> are set to nil which are used as arrays to store XTick and YTick objects corresponding to major(and minor) ticks of X-axis and major(and minor) ticks of Y-axis respectively. Finally, the font size of the title is set to 25 points.</p> <h2 id="the-plot">The Plot</h2> <p>Now, we have defined the subplot i.e. the axes object in which we want to draw our plot. The next lines of code are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">axes</span><span class="p">.</span><span class="nf">scatter!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="c1"># Setting scatter as the type of subplot</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, the function <strong>scatter!</strong> is called for the axes object. The block associated with the <strong>scatter!</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
</code></pre></div></div> <p>The block is a block of lines having commands which in this example are used for specifying properties of the plot in the subplot. This block is given to the <strong>scatter!</strong> function as an input:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scatter!</span><span class="p">(</span><span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">add_plot!</span> <span class="ss">:Scatter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the private <strong>add_plot!</strong> function:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_plot!</span> <span class="n">klass</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">plot</span> <span class="o">=</span> <span class="no">Kernel</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="s2">"Rubyplot::Artist::Plot::</span><span class="si">#{</span><span class="n">klass</span><span class="si">}</span><span class="s2">"</span><span class="p">).</span><span class="nf">new</span> <span class="nb">self</span>
  <span class="k">yield</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="n">plot</span>
<span class="k">end</span>
</code></pre></div></div> <p>The <strong>add_plot!</strong> function takes input as the class name for the plot which is Scatter in this example and the block is passed, then using Kernel a new object of the input class is created and is stored in <em>plot</em> variable which in this example is Scatter plot and so a <em>Scatter</em> object is created and stored in <em>plot</em> variable.<br/> Then yield executes the block if block is given i.e. block_given?==true. After executing the block i.e. creating the plot and setting up the characteristics of the blog, the <em>plot</em> is appended in <em>plots</em> array.</p> <h3 id="scatter-plot">Scatter Plot</h3> <p>Now, before executing to the block, a Scatter object is initialized:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">super</span>
  <span class="vi">@marker_size</span> <span class="o">=</span> <span class="mf">1.0</span>
  <span class="vi">@marker_type</span> <span class="o">=</span> <span class="ss">:circle</span>
  <span class="vi">@marker_border_color</span> <span class="o">=</span> <span class="ss">:black</span>
  <span class="c1"># set fill to nil for the benefit of hollow markers so that legend</span>
  <span class="c1"># color defaults to :black in case user does not specify.</span>
  <span class="vi">@marker_fill_color</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first calls the base class which is inherited by Scatter, the initialize function is called. After that, different properties of the plot are set to default values which are stored in variables like marker size (set to 1), marker type (set to circle) which can be of different types like, triangle, plus, star, etc. (around 35 types available), marker border colour (set to black) and marker fill colour (set to nil). Now, the initialize function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span> <span class="n">axes</span>
<span class="k">super</span><span class="p">(</span><span class="n">axes</span><span class="p">.</span><span class="nf">abs_x</span><span class="p">,</span> <span class="n">axes</span><span class="p">.</span><span class="nf">abs_y</span><span class="p">)</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">label: </span><span class="s1">''</span><span class="p">,</span>
    <span class="ss">color: :default</span>
  <span class="p">}</span>
  <span class="vi">@normalized_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">y_values: </span><span class="kp">nil</span><span class="p">,</span>
    <span class="ss">x_values: </span><span class="kp">nil</span>
  <span class="p">}</span>
  <span class="vi">@stroke_width</span> <span class="o">=</span> <span class="mf">4.0</span>
  <span class="vi">@stroke_opacity</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">end</span>
</code></pre></div></div> <p>This again calls the base class of artist which is inherited by this base class, the initialize function is called. After that, an <em>axes</em> variable is initialized to store the axes pointer, a <em>data</em> hash is initialized which stores different properties of the subplot like label and colour for the legend, a <em>normalized_data</em> hash is initialized to store normalised data (not used), stroke width and stroke opacity (i.e. border width and opacity) are initialized with values 4 and 0 respectively. The initialize function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
<span class="k">end</span>
</code></pre></div></div> <p>This initialized function sets the absolute values (i.e. in Rubyplot coordinates) of the origin of this axes object i.e. of this subplot (which is the upper left corner for Magick backend).</p> <h4 id="the-block-properties-of-the-scatter-plot">The Block (properties of the scatter plot)</h4> <p>Now, the scatter object has been initialized and the block will be executed which sets the data to be plotted and other properties of the scatter plot. The block is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
</code></pre></div></div> <p>Here p is the scatter plot object. First, the data is set to the <em>x1</em> and the <em>y1</em> arrays defined earlier:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function in base of plots</span>
<span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)</span>
  <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_values</span>
  <span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_values</span>
<span class="k">end</span>
</code></pre></div></div> <p>This stores the <em>x_vales</em> and <em>y_values</em> in the <em>data</em> hash. Then the label of the scatter plot is set:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function in base of plots</span>
<span class="k">def</span> <span class="nf">label</span><span class="o">=</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="vi">@data</span><span class="p">[</span><span class="ss">:label</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
<span class="k">end</span>
</code></pre></div></div> <p>This overwrites the value of <em>label</em> in <em>data</em> hash.<br/> Next, <em>marker_border_color</em> is set which is a variable of scatter plot which describes the colour of the border of the markers. So, in this example the colour is set to blue i.e. the variable <em>marker_border_color</em> is set to the symbol <em>:blue</em>.<br/> Next, <em>marker_fill_color</em> is set which is a variable of scatter plot which describes the colour to be filled in the markers. So, in this example the colour is set to blue i.e. the variable <em>marker_fill_color</em> is set to the symbol <em>:blue</em>.<br/> Finally, the marker type is set to circle i.e. the variable <em>marker_type</em> is set to the symbol <em>:circle</em>.</p> <h2 id="axes-properties-properties-of-the-subplot">Axes properties (properties of the subplot)</h2> <p>Finally after setting the scatter plot properties, the properties of the subplot i.e. the axes object are set:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Nice plot"</span> <span class="c1"># defining title of the plot</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_title</span> <span class="o">=</span> <span class="s2">"X data"</span> <span class="c1"># defining title of X axis</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_title</span> <span class="o">=</span> <span class="s2">"Y data"</span> <span class="c1"># defining title of Y axis</span>
</code></pre></div></div> <p>Axes object has these variables <em>title</em>, <em>x_title</em>, <em>y_title</em> which store a string which defines the title of the subplot, title of X-axis and title of Y-axis respectively.</p> <h2 id="writing-figure">Writing Figure</h2> <p>Till now we have only defined the properties and the data of the figure and have not actually plotted anything. Also notice that till now we havenâ€™t actually made of the use of backend and have only used the frontend, one aim of Rubyplot is having a backend-agnostic frontend i.e. frontend should not be dependent on the backend.<br/> Now we finally call the write function of the figure which actually draws everything and stores the figure as an Image:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"scatterplot.png"</span><span class="p">)</span> <span class="c1"># Drawing the figure and saving it</span>
</code></pre></div></div> <p>Now, the write function of figure is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_height</span> <span class="o">=</span> <span class="vi">@height</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_width</span> <span class="o">=</span> <span class="vi">@width</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">figure</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"RUBYPLOT_BACKEND"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"MAGICK"</span>
    <span class="n">set_background_gradient</span>
  <span class="k">end</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">init_output_device</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span> <span class="p">}</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">write</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">stop_output_device</span>
<span class="k">end</span>
</code></pre></div></div> <p>Now, we start using the backend (it is initialized) and setting its properties, first the variables <em>canvas_height</em> and <em>canvas_width</em> are sset as the height and width of the canvas (figure), then the <em>figure</em> variable points to the Figure object.<br/> Now the function <strong>set_background_gradient</strong> is called which is exclusive to Magick backend and its purpose is to make the canvas i.e. an Magick::Image object (P.S. - In future, this function will be shifted to the backend so that both backends are consistent).</p> <h3 id="initializing-the-backend">Initializing the backend</h3> <p>When any function or variable of the backend is called for the first time, the backend is initialized and its constructor is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span>
  <span class="vi">@axes_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">end</span>
</code></pre></div></div> <p>In Magick backend, during initialization an <em>axes_map</em> hash is defined which will later be used to store properties for X and Y axis corresponding to this particular axes which are currently being used.</p> <h3 id="setting-up-the-background-gradient-creating-the-figure">Setting up the background gradient (creating the Figure)</h3> <p>Now, the <strong>set_background_gradient</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_background_gradient</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">set_base_image_gradient</span><span class="p">(</span>
    <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:background_colors</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
    <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:background_colors</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
    <span class="vi">@width</span><span class="p">,</span>
    <span class="vi">@height</span><span class="p">,</span>
    <span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:background_direction</span><span class="p">]</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the <strong>set_base_image_gradient</strong> function in the backend which creates the <em>base_image</em> variable which stores the Magick::Image object which is the canvas on which everything will be drawn, the canvas backgroung can have any solid colour or a gradient of two colours. <br/> The first inputs given are the background top and bottom colour for the background gradient of the figure (<em>theme_options</em> hash was set up while initializing the figure), then the width and height of the figure and finally the gradient direction is set which is nil currently and will get take on the default value later.</p> <p>Now, the <strong>set_base_image_gradient</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_base_image_gradient</span><span class="p">(</span><span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">direct</span><span class="o">=</span><span class="ss">:top_bottom</span><span class="p">)</span>
  <span class="vi">@base_image</span> <span class="o">=</span> <span class="n">render_gradient</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">direct</span>
<span class="k">end</span>
</code></pre></div></div> <p>So the inputs to this are as explained above and the direction of the gradient is set to the symbol <em>:top_bottom</em>. So, the variable <em>base_image</em> is created which stores the Magick::Image object which is the figure, the value of <em>base_image</em> is returned by the function which is <strong>render_gradient</strong> which takes the same inputs as <strong>set_base_image_gradient</strong>, this function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Render a gradient and return an Image.</span>
<span class="k">def</span> <span class="nf">render_gradient</span><span class="p">(</span><span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">direct</span><span class="p">)</span>
  <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">scale_figure</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
  <span class="n">gradient_fill</span> <span class="o">=</span> <span class="k">case</span> <span class="n">direct</span>
                  <span class="k">when</span> <span class="ss">:bottom_top</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">top_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:left_right</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:right_left</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">top_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:topleft_bottomright</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:topright_bottomleft</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">top_color</span><span class="p">)</span>
                  <span class="k">else</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">)</span>
                  <span class="k">end</span>
  <span class="no">Magick</span><span class="o">::</span><span class="no">Image</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">gradient_fill</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>Now first the <strong>scale_figure</strong> function is called which scales the figure according to the unit of dimensions of the figure (stored in <em>figsize_units</em>) to pixels as Magick backend uses pixels as its unit. After scaling the figure the gradient of the figure background is stored in <em>gradient_fill</em>, this is a GradientFill object from ImageMagick which takes the inputs x,y coordinates of starting and ending of the gradient and the starting and ending colours.<br/> Now, a new Magick::Image object is created (with the properties set) and returned which gets stored in <em>base_image</em>.</p> <p>The <strong>scale_figure</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function to convert figure size to pixels</span>
<span class="k">def</span> <span class="nf">scale_figure</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
  <span class="p">[</span><span class="n">width</span> <span class="o">*</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">],</span> <span class="n">height</span> <span class="o">*</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">]]</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, in this function the width and height are multiplied with constants stored in <em>PIXEL_MULTIPLIERS</em> hash, i.e. to convert from inch to pixels, the width and size are multiplied with a constant. The <em>PIXEL_MULTIPLIERS</em> hash is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Multiplier needed to convert given unit into pixels. (Magick default).</span>
<span class="no">PIXEL_MULTIPLIERS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">inch: </span><span class="mi">96</span><span class="p">,</span>
  <span class="ss">cm: </span><span class="mf">39.7953</span><span class="p">,</span>
  <span class="ss">pixel: </span><span class="mi">1</span>
<span class="p">}.</span><span class="nf">freeze</span>
</code></pre></div></div> <h3 id="setting-up-the-output-device">Setting up the Output device</h3> <p>After setting up the background gradient, the <strong>init_output_device</strong> function is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">init_output_device</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
</code></pre></div></div> <p>This function takes input as the name of the image to be written and saved and the device to which it is to be saved which by default is <em>:file</em> symbol which represents the current folder of Rubyplot (device attribute is not used currently). The <strong>init_output_device</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">init_output_device</span> <span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span>
  <span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span> <span class="o">=</span> <span class="n">scale_figure</span><span class="p">(</span><span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span><span class="p">)</span>
  <span class="vi">@draw</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="n">file_name</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first modifies the <em>canvas_width</em> and the <em>canvas_height</em> variables according to the unit of the figure (<strong>scale_figure</strong> function was explained earlier). Then three new variables are defined <em>draw</em>, <em>axes</em> and <em>text</em> which are Magick::Draw objects which are used to draw shapes, X/Y axes and text respectively. Finally the <em>file_name</em> variable stores the file name string.</p> <h3 id="processing-the-data-in-subplots">Processing the data in subplots</h3> <p>Now, First the data in subplots is processed:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div> <p>For each subplot (axes object) stored in <em>subplots</em> array the function <strong>process_data</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_data</span>
  <span class="n">assign_default_label_colors</span>
  <span class="n">consolidate_plots</span>
  <span class="vi">@plots</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span>
  <span class="n">set_axes_ranges</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first calls the function <strong>assign_default_label_colors</strong> which sets the default colours for the each of the plots in this subplot, the function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">assign_default_label_colors</span>
  <span class="vi">@plots</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
    <span class="k">if</span> <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">==</span> <span class="ss">:default</span>
      <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">theme_options</span><span class="p">[</span><span class="ss">:label_colors</span><span class="p">][</span>
        <span class="n">i</span> <span class="o">%</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">theme_options</span><span class="p">[</span><span class="ss">:label_colors</span><span class="p">].</span><span class="nf">size</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>In this function, for each plot in <em>plots</em> array (in this example only 1 scatter plot) the default colours are set, the value returned by the <strong>color</strong> function is checked and if it is <em>:default</em> then the default colours are set, the <strong>color</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">color</span>
  <span class="vi">@marker_fill_color</span> <span class="o">||</span> <span class="vi">@marker_border_color</span> <span class="o">||</span> <span class="ss">:default</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function returns the first value which is not nil (will return <em>:default</em> if both variables are nil).<br/> So, this returns :default which causes the <strong>assign_default_label_colors</strong> function to go into the if case, and a colour is set using the <strong>color</strong> function, the colour set is decided by the <em>theme_options</em> hash using the key <em>:label_colors</em> which has an array of colours and the colour at the index ` i % @figure.theme_options[:label_colors].size` and in this example i = 0 since there is only one plot and the <em>:label_colors</em> variable is set to default (so 0 index is chosen and the colour present at 0 index is strong_blue). The <strong>color</strong> function used for setting colours is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Set both marker_fill_color and marker_border_color to the same color.</span>
<span class="k">def</span> <span class="nf">color</span><span class="o">=</span> <span class="n">color</span>
  <span class="vi">@marker_fill_color</span> <span class="o">=</span> <span class="n">color</span>
  <span class="vi">@marker_border_color</span> <span class="o">=</span> <span class="n">color</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, <em>marker_fill_color</em> and <em>marker_border_color</em> are set to the colour which was chosen as default i.e. strong_blue in this example.</p> <p>Now, next the function <strong>consolidate_plots</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">consolidate_plots</span>
  <span class="n">bars</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">Bar</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">bars</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">Bar</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiBars</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">bar_plots: </span><span class="n">bars</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">stacked_bars</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">StackedBar</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">stacked_bars</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">StackedBar</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiStackedBar</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">stacked_bars: </span><span class="n">stacked_bars</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">candle_sticks</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">CandleStick</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">candle_sticks</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">CandleStick</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiCandleStick</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span>
      <span class="ss">candle_sticks: </span><span class="n">candle_sticks</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">box_plots</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">BoxPlot</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">box_plots</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">BoxPlot</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiBoxPlot</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span>
      <span class="ss">box_plots: </span><span class="n">box_plots</span><span class="p">)</span>
  <span class="k">end</span>        
<span class="k">end</span>
</code></pre></div></div> <p>This function checks if multiple bar plots/stacked bar plots/candle stick plots/box plots are present and if there are multiple of these plots then a new multi bar plot/multi stacked bar plot/multi candle stick plot/multi box plot is created correspondingly. In this example no such plot is present and hence the function does not do anything.</p> <p>Next, for each plot present in this subplot i.e. in the <em>plots</em> array, the <strong>process_data</strong> function is called. In this example only one scatter plot is present and hence the <strong>process_data</strong> function of scatter plot is called (which is inherited from the base and is present in the base):</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_data</span>
  <span class="vi">@y_min</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">].</span><span class="nf">min</span>
  <span class="vi">@y_max</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">].</span><span class="nf">max</span>
  <span class="vi">@x_min</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">min</span>
  <span class="vi">@x_max</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">max</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function stores the maximum and minimum X and Y values in the corresponding variables.</p> <p>Finally, the <strong>set_axes_ranges</strong> function is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_axes_ranges</span>
  <span class="n">set_xrange</span>
  <span class="n">set_yrange</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the functions <strong>set_xrange</strong> and <strong>set_yrange</strong> which are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_xrange</span>
  <span class="k">if</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:x_min</span><span class="p">).</span><span class="nf">min</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">max_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:x_max</span><span class="p">).</span><span class="nf">max</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">set_yrange</span>
  <span class="k">if</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:y_min</span><span class="p">).</span><span class="nf">min</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">max_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:y_max</span><span class="p">).</span><span class="nf">max</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Both of these functions first check if the corresponding maximum and minimum values are nil or not (which they are by default) in <em>x_axis</em> and <em>y_axis</em> which store the XAxis and YAxis objects respectively, and if they are nil (which they are in this example currently) then it calculates the minimum and maximum values across all the plots present in this subplot(i.e. in the <em>plots</em> array) and then sets the corresponding variables to the corresponding values.</p> <h3 id="drawing-the-subplots">Drawing the Subplots</h3> <p>Next each subplot in <em>subplots</em> array is drawn:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div> <p>The draw function of axes is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Write an image to a file by communicating with the backend.</span>
<span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">active_axes</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="n">configure_title</span>
  <span class="n">configure_legends</span>
  <span class="n">assign_x_ticks</span>
  <span class="n">assign_y_ticks</span>
  <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
  <span class="vi">@legend_box</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@plots</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>First the <em>active_axes</em> variable is set to the current axes object which is to be drawn, next the function <strong>configure_title</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Figure out the co-ordinates of the title text w.r.t Axes.</span>
<span class="k">def</span> <span class="nf">configure_title</span>
  <span class="vi">@texts</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@title</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="n">abs_x</span> <span class="o">+</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">abs_y: </span><span class="n">abs_y</span> <span class="o">+</span> <span class="n">height</span><span class="p">,</span>
    <span class="ss">font: </span><span class="vi">@font</span><span class="p">,</span> <span class="ss">color: </span><span class="vi">@font_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@title_font_size</span><span class="p">,</span> <span class="ss">internal_label: </span><span class="s1">'axes title.'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function sets the title of this subplot (in this example the title is set to â€˜Nice plotâ€™). So a new Text object is added to the <em>texts</em> array of the active axes, the inputs for initializing the Text object are first the text, then the owner of this text i.e. the active axes, then the x coordinate and y coordinate in Rubyplot coordinates, then the font, font colour, font size (in points) and an internal label. Currently, the position of title is kept static and is at the center of the width and at maximum height of the axes (adding these with the x and y origin values of the axes gives the Rubyplot coordinates of the text). The initialize function of Text is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">abs_x</span><span class="p">:,</span> <span class="n">abs_y</span><span class="p">:,</span><span class="ss">font: :times_roman</span><span class="p">,</span>
  <span class="ss">color: :black</span><span class="p">,</span> <span class="n">size</span><span class="p">:,</span> <span class="ss">internal_label: </span><span class="s1">''</span><span class="p">,</span> <span class="ss">rotation: </span><span class="kp">nil</span><span class="p">,</span>
  <span class="ss">weight: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">halign: :normal</span><span class="p">,</span> <span class="ss">valign: :normal</span><span class="p">,</span> <span class="ss">direction: :left_right</span><span class="p">)</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="n">text</span>
  <span class="vi">@owner</span> <span class="o">=</span> <span class="n">owner</span>
  <span class="vi">@font</span> <span class="o">=</span> <span class="n">font</span>
  <span class="vi">@color</span> <span class="o">=</span> <span class="n">color</span>
  <span class="vi">@size</span> <span class="o">=</span> <span class="n">size</span>
  <span class="vi">@internal_label</span> <span class="o">=</span> <span class="n">internal_label</span>
  <span class="vi">@rotation</span> <span class="o">=</span> <span class="n">rotation</span>
  <span class="k">if</span> <span class="no">HAlignment</span><span class="p">.</span><span class="nf">include?</span> <span class="n">halign</span>
    <span class="vi">@halign</span> <span class="o">=</span> <span class="n">halign</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="s2">"Invalid horizontal alignment </span><span class="si">#{</span><span class="n">halign</span><span class="si">}</span><span class="s2">."</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="no">VAlignment</span><span class="p">.</span><span class="nf">include?</span> <span class="n">valign</span>
    <span class="vi">@valign</span> <span class="o">=</span> <span class="n">valign</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="s2">"Invalid vertical alignment </span><span class="si">#{</span><span class="n">valign</span><span class="si">}</span><span class="s2">."</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This sets all the required variables including the rotation for text if required and the alignment too.</p> <h4 id="legend-box">Legend Box</h4> <p>After configuring the label, the function <strong>configure_legends</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Figure out co-ordinates of the legends</span>
<span class="k">def</span> <span class="nf">configure_legends</span>
  <span class="vi">@legend_box</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">LegendBox</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span> <span class="ss">abs_x: </span><span class="n">legend_box_ix</span><span class="p">,</span> <span class="ss">abs_y: </span><span class="n">legend_box_iy</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates a new LegendBox object which defines the legend of the subplot, the inputs given are the owner of this legend box i.e. the subplot, then the absolute value (i.e. in Rubyplot coordinates) of x and y coordinates which correspond to the lower right corner of the legend box. The functions <strong>legend_box_ix</strong> and <strong>legend_box_ix</strong> are called to give the absolute X and Y coordinate for the lower right corner of the legend box. The functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X co-ordinate of the legend box depending on value of @legend_box_position.</span>
<span class="k">def</span> <span class="nf">legend_box_ix</span>
  <span class="k">case</span> <span class="vi">@legend_box_position</span>
  <span class="k">when</span> <span class="ss">:top</span>
    <span class="n">abs_x</span> <span class="o">+</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Y co-ordinate of the legend box depending on value of @legend_box_position.</span>
<span class="k">def</span> <span class="nf">legend_box_iy</span>
  <span class="k">case</span> <span class="vi">@legend_box_position</span>
  <span class="k">when</span> <span class="ss">:top</span>
    <span class="n">abs_y</span> <span class="o">+</span> <span class="n">height</span> <span class="o">-</span> <span class="n">top_margin</span> <span class="o">-</span> <span class="n">legend_margin</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>These functions set the X coordinate to center of width and Y coordinate to the maximum height of the axes excluding the corresponding margins.</p> <p>The initialize function of the LegendBox is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">abs_x</span><span class="p">:,</span> <span class="n">abs_y</span><span class="p">:)</span>
  <span class="k">super</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@border_color</span> <span class="o">=</span> <span class="ss">:black</span>
  <span class="vi">@legends</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">configure_dimensions</span>
  <span class="n">configure_legends</span>
  <span class="n">configure_legend_box</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first calls the initialize of parent class i.e. base:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
<span class="k">end</span>
</code></pre></div></div> <p>which just sets the lower right coordinates of the legend box, next <em>axes</em> is set to its owner i.e. the subplot and then <em>border_color</em> of the legend box i.e. the colour of the outer rectangle of the legend box i.e. the colour of the box. Then the array <em>legends</em> is created which stores the legend objects. Next, the function <strong>configure_dimensions</strong> is called which sets the dimensions for the legend box:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_dimensions</span>
  <span class="vi">@legends_height</span> <span class="o">=</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">plots</span><span class="p">.</span><span class="nf">size</span> <span class="o">*</span> <span class="n">per_legend_height</span>
  <span class="vi">@legends_width</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">width</span>
  <span class="vi">@height</span> <span class="o">=</span> <span class="vi">@legends_height</span> <span class="o">+</span> <span class="n">top_margin</span> <span class="o">+</span> <span class="n">bottom_margin</span>
  <span class="vi">@width</span> <span class="o">=</span> <span class="vi">@legends_width</span> <span class="o">+</span> <span class="n">left_margin</span> <span class="o">+</span> <span class="n">right_margin</span>
<span class="k">end</span>
</code></pre></div></div> <p>The functions called here are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">top_margin</span>
  <span class="no">TOP_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_height</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">bottom_margin</span>
  <span class="no">BOTTOM_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_height</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">left_margin</span>
  <span class="no">LEFT_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_width</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">right_margin</span>
  <span class="no">RIGHT_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_width</span>
<span class="k">end</span>

<span class="c1"># Height of each legend in Rubyplot Artist Co-ordinates.</span>
<span class="k">def</span> <span class="nf">per_legend_height</span>
  <span class="mi">5</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, in <strong>configure_dimensions</strong> first the total height of legends is set which is number of plots * height per legend (which is set to 5 Rubyplot coordinates), then the length of the legends is width of the subplot * 0.2, Then the total height and width for the legend box is calculated i.e. margins are incorporated (each margin ratio is set to 0.1).</p> <p>After fixing the legend box dimensions, the legends are created which are Legend objects using the <strong>configure_legends</strong> function, which is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legends</span>
  <span class="vi">@axes</span><span class="p">.</span><span class="nf">plots</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">plot</span><span class="p">,</span> <span class="n">count</span><span class="o">|</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">plot</span><span class="p">.</span><span class="nf">label</span> <span class="o">!=</span> <span class="s1">''</span>      
    <span class="vi">@legends</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Legend</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="nb">self</span><span class="p">,</span>
      <span class="vi">@axes</span><span class="p">,</span>
      <span class="ss">text: </span><span class="n">plot</span><span class="p">.</span><span class="nf">label</span><span class="p">,</span>
      <span class="ss">color: </span><span class="n">plot</span><span class="p">.</span><span class="nf">color</span><span class="p">,</span>
      <span class="ss">abs_x: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="n">left_margin</span><span class="p">,</span>
      <span class="ss">abs_y: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="n">per_legend_height</span> <span class="o">+</span> <span class="n">bottom_margin</span><span class="p">,</span>
    <span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates a legend which is a Legend object having a square with the colour of the data and its label for every plot stored in the <em>plots</em> array. So for each plot a Legend object is made and added to the <em>legends</em> array, any plot with an empty label is skipped. The inputs given to create a new Legend object are first the owner of this legend i.e. the legend box, then the subplot to which it belongs i.e. the axes object, then the label of the plot, colour of the plot and finally the x,y coordinate of the lower left corner of the legend in Rubyplot coordinates. The initialize function of Legend is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">legend_box</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">text</span><span class="p">:,</span> <span class="n">color</span><span class="p">:,</span><span class="n">abs_x</span><span class="p">:,</span><span class="n">abs_y</span><span class="p">:)</span>
  <span class="k">super</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@legend_box</span> <span class="o">=</span> <span class="n">legend_box</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="n">text</span>
  <span class="vi">@color</span> <span class="o">=</span> <span class="n">color</span>
  <span class="vi">@legend_box_size</span> <span class="o">=</span> <span class="vi">@legend_box</span><span class="p">.</span><span class="nf">per_legend_height</span> <span class="o">-</span>
                     <span class="p">(</span><span class="no">TOP_MARGIN</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span><span class="p">)</span> <span class="c1"># size of the color box of the legend.</span>
  <span class="vi">@font_size</span> <span class="o">=</span> <span class="mf">20.0</span>
  <span class="vi">@font</span> <span class="o">=</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">font</span>
  <span class="vi">@font_color</span> <span class="o">=</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">font_color</span>
  <span class="n">configure_legend_color_box</span>
  <span class="n">configure_legend_text</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here first the constructor(initialize function) of the parent class base is called which just sets the x,y coorindates of the lower left corner, then all the important variables are set according to the input and then the <strong>configure_legend_color_box</strong> is called which creates the square for the legend:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legend_color_box</span>
  <span class="vi">@legend_color_box</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Rectangle</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">x1: </span><span class="vi">@abs_x</span><span class="p">,</span>
    <span class="ss">y1: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span><span class="p">,</span>
    <span class="ss">x2: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="vi">@legend_box_size</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="vi">@legend_box_size</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">abs: </span><span class="kp">true</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function stores a Rectangle object in the variable <em>legend_color_box</em>. The inputs given to create a new Rectangle object are first the owner of the rectangle then the x,y coorindates of lower left and upper right corners, then the border colour and the colour to be filled and finally absolute flag representing whether the coordinates are in Rubyplot cooridnates(abs = True) or not(abs = False). The initialize function of Rectangle class is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span><span class="n">x1</span><span class="p">:,</span><span class="n">y1</span><span class="p">:,</span><span class="n">x2</span><span class="p">:,</span><span class="n">y2</span><span class="p">:,</span><span class="n">border_color</span><span class="p">:,</span><span class="ss">fill_color: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
  <span class="vi">@x1</span> <span class="o">=</span> <span class="n">x1</span>
  <span class="vi">@x2</span> <span class="o">=</span> <span class="n">x2</span>
  <span class="vi">@y1</span> <span class="o">=</span> <span class="n">y1</span>
  <span class="vi">@y2</span> <span class="o">=</span> <span class="n">y2</span>
  <span class="vi">@border_color</span> <span class="o">=</span> <span class="n">border_color</span>
  <span class="vi">@fill_color</span> <span class="o">=</span> <span class="n">fill_color</span>
  <span class="vi">@abs</span> <span class="o">=</span> <span class="n">abs</span>
<span class="k">end</span>
</code></pre></div></div> <p>This just sets all the variables according to the input.</p> <p>Now, the <strong>configure_legend_text</strong> is called which creates the text for the legend:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legend_text</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@text</span><span class="p">,</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="vi">@legend_box_size</span> <span class="o">+</span> <span class="no">BOX_AND_TEXT_SPACE</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="ss">font: </span><span class="vi">@font</span><span class="p">,</span>
    <span class="ss">color: </span><span class="vi">@font_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@font_size</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates a Text object and stores it in the <em>text</em> variable. The inputs are given to create the Text object (Text object was discussed earlier), here the <em>BOX_AND_TEXT_SPACE</em> represents the space between the box and the text which is set to 0.5 .</p> <p>So, after configuring the dimensions of the legend box and the legends, the legend box is configured by calling the <em>configure_legend_box</em> function:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legend_box</span>
  <span class="vi">@bounding_box</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Rectangle</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">x1: </span><span class="vi">@abs_x</span><span class="p">,</span>
    <span class="ss">y1: </span><span class="vi">@abs_y</span><span class="p">,</span>
    <span class="ss">x2: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="vi">@width</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="vi">@height</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@border_color</span><span class="p">,</span>
    <span class="ss">abs: </span><span class="kp">true</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates the bounding box which is the outer rectangle of the legend box. The <em>bounding_box</em> is a Rectangle object (which was discussed earlier).</p> <h3 id="x-and-y-ticks">X and Y ticks</h3> <p>Finally, the LegendBox object is created and we continue to the draw function of the axes i.e. the subplot.<br/> Next the functions <strong>assign_x_ticks</strong> and <strong>assign_y_ticks</strong> are called which assign the ticks to the X and Y axes. The functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">assign_x_ticks</span>
  <span class="n">value_distance</span> <span class="o">=</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">spread</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks_count</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">unless</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span> <span class="c1"># create labels if not present</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span> <span class="o">=</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks_count</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
      <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">value_distance</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">XTick</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">map!</span><span class="p">.</span><span class="nf">with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">tick_label</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
      <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">XTick</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
        <span class="nb">self</span><span class="p">,</span>
        <span class="ss">coord: </span><span class="n">i</span> <span class="o">*</span> <span class="n">value_distance</span> <span class="o">+</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">,</span>
        <span class="ss">label: </span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Utils</span><span class="p">.</span><span class="nf">format_label</span><span class="p">(</span><span class="n">tick_label</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">assign_y_ticks</span>
  <span class="n">value_distance</span> <span class="o">=</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">spread</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks_count</span><span class="p">.</span><span class="nf">to_f</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">unless</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">..</span><span class="n">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]).</span><span class="nf">step</span><span class="p">(</span><span class="n">value_distance</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">YTick</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">map!</span><span class="p">.</span><span class="nf">with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">tick_label</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
      <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">YTick</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
        <span class="nb">self</span><span class="p">,</span>
        <span class="ss">coord: </span><span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">value_distance</span><span class="p">,</span>
        <span class="ss">label: </span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Utils</span><span class="p">.</span><span class="nf">format_label</span><span class="p">(</span><span class="n">tick_label</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>These functions decide the coordinates for the ticks according to the number of ticks required and then these functions create an array to store the ticks which are <em>XTick</em> and <em>YTick</em> objects. The ticks are of two types (both for X and Y axes), minor tick and major tick which represent a smaller and a bigger tick relatively (the size of the major tick is twice the size of minor tick).<br/> <strong>P.S. - Currently the ticks are not implemented for Magick backend and changes are required in the frontend of ticks as well and hence ticks will be discussed in detail in a later blog.</strong></p> <h3 id="x-axis-and-y-axis-1">X axis and Y axis</h3> <p>Now, returning to the draw function of the axes, we actually start to draw the plots (Notice, till now we havenâ€™t actually drawn anything). So the next lines of code are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@x_axis</span><span class="p">.</span><span class="nf">draw</span>
<span class="vi">@y_axis</span><span class="p">.</span><span class="nf">draw</span>
</code></pre></div></div> <p>The <strong>draw</strong> function of XAxis and YAxis objects (which were stored in the variables <em>x_axis</em> and <em>y_axis</em> respectively) is called to draw the axes:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X Axis</span>
<span class="k">def</span> <span class="nf">draw</span>
  <span class="n">configure_title</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_x_axis</span><span class="p">(</span>
    <span class="ss">origin: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="ss">major_ticks: </span><span class="vi">@major_ticks</span><span class="p">,</span>
    <span class="ss">minor_ticks: </span><span class="vi">@minor_ticks</span><span class="p">,</span>
    <span class="ss">major_ticks_count: </span><span class="vi">@major_ticks_count</span>
  <span class="p">)</span>
  <span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Y Axis</span>
<span class="k">def</span> <span class="nf">draw</span>
  <span class="n">configure_title</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_y_axis</span><span class="p">(</span>
    <span class="ss">origin: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="ss">major_ticks: </span><span class="vi">@major_ticks</span><span class="p">,</span>
    <span class="ss">minor_ticks: </span><span class="vi">@minor_ticks</span><span class="p">,</span>
    <span class="ss">major_ticks_count: </span><span class="vi">@major_ticks_count</span>
  <span class="p">)</span>
  <span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>First both the X and Y axes call the function <strong>configure_title</strong> which sets the title of X axis and Y axis respectively:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X Axis</span>
<span class="k">def</span> <span class="nf">configure_title</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">'X axis'</span> <span class="k">if</span> <span class="vi">@title</span> <span class="o">==</span> <span class="s1">''</span>
  <span class="vi">@texts</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@title</span><span class="p">,</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@title_font_size</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_y</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_x</span> <span class="o">+</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">width</span><span class="o">/</span><span class="mi">2</span>
  <span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Y Axis</span>
<span class="k">def</span> <span class="nf">configure_title</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">'Y axis'</span> <span class="k">if</span> <span class="vi">@title</span> <span class="o">==</span> <span class="s1">''</span>
  <span class="vi">@texts</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@title</span><span class="p">,</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">rotation: </span><span class="o">-</span><span class="mf">90.0</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_x</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_y</span> <span class="o">+</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@title_font_size</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first checks if the title is empty and if it is the title is set to â€˜X axisâ€™ and â€˜Y axisâ€™ for X axis and Y axis respectively, this is done to set the default titles. After modifying the <em>title</em> variable if needed, a new Text object (which was discussed earlier) for the title is added to the <em>texts</em> array for both X and Y axes.<br/> One thing to note is that rotation is given to the Text object for the Y-axis as the text is to be printed vertically.</p> <p>After configuring the title, the backend functions <strong>draw_x_axis</strong> and <strong>draw_y_axis</strong> are called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_x_axis</span><span class="p">(</span><span class="n">minor_ticks</span><span class="p">:,</span> <span class="n">origin</span><span class="p">:,</span> <span class="n">major_ticks</span><span class="p">:,</span> <span class="n">major_ticks_count</span><span class="p">:)</span>
  <span class="k">if</span> <span class="vi">@axes_map</span><span class="p">[</span><span class="n">active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">nil?</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
      <span class="ss">axes: </span><span class="vi">@active_axes</span><span class="p">,</span>
      <span class="ss">x_origin: </span><span class="n">origin</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">merge!</span><span class="p">(</span><span class="ss">x_origin: </span><span class="n">origin</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">draw_y_axis</span><span class="p">(</span><span class="n">minor_ticks</span><span class="p">:,</span> <span class="n">origin</span><span class="p">:,</span> <span class="n">major_ticks</span><span class="p">:,</span> <span class="n">major_ticks_count</span><span class="p">:)</span>
  <span class="k">if</span> <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">nil?</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
      <span class="ss">axes: </span><span class="vi">@active_axes</span><span class="p">,</span>
      <span class="ss">y_origin: </span><span class="n">origin</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">merge!</span><span class="p">(</span><span class="ss">y_origin: </span><span class="n">origin</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>The inputs given to the functions are the array for minor ticks (having XTick or YTick objects), the origin, the array for major ticks (having XTick or YTick objects) and finally the number of major ticks to be drawn.<br/> The functions first check if the <em>axes_map</em> hash (initialized in the initialize function of the magick wrapper i.e. the backend) is empty (i.e., if the key for the current axes object stored in <em>active_axes</em> is not present) and if it is then a new key, value pair is created otherwise the value is added. The value for a key i.e. a subplot (axes) object is an array which stores the axes to which this value belongs, the origin of X-axis and Y-axis.<br/> Note that there is only one value array for both X-axis and Y-axis for axes object i.e. a subplot.<br/> So, the origins are stored in a hash and after that, in the <strong>draw</strong> function for both the axes, this command is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
</code></pre></div></div> <p>This command calls the <strong>draw</strong> function for each of the Text objects present in <em>texts</em> array. The <strong>draw</strong> function of the Text object is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_text</span><span class="p">(</span>
    <span class="vi">@text</span><span class="p">,</span>
    <span class="ss">color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">font: </span><span class="vi">@font</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@size</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@abs_x</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@abs_y</span><span class="p">,</span>
    <span class="ss">rotation: </span><span class="vi">@rotation</span><span class="p">,</span>
    <span class="ss">halign: </span><span class="vi">@halign</span><span class="p">,</span>
    <span class="ss">valign: </span><span class="vi">@valign</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the <strong>draw_text</strong> of the backend and passes all the useful variables, the <strong>draw_text</strong> is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="ss">color: :default</span><span class="p">,</span><span class="ss">font: </span><span class="kp">nil</span><span class="p">,</span><span class="n">size</span><span class="p">:,</span>
        <span class="ss">font_weight: </span><span class="no">Magick</span><span class="o">::</span><span class="no">NormalWeight</span><span class="p">,</span> <span class="n">halign</span><span class="p">:,</span> <span class="n">valign</span><span class="p">:,</span>
        <span class="n">abs_x</span><span class="p">:,</span><span class="n">abs_y</span><span class="p">:,</span><span class="ss">rotation: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">stroke: </span><span class="s1">'transparent'</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">true</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">text</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="n">within_window</span><span class="p">(</span><span class="n">abs</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">abs_x</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">abs_y</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>

      <span class="vi">@text</span><span class="p">.</span><span class="nf">fill</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">color</span><span class="p">]</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">font</span> <span class="o">=</span> <span class="n">font</span><span class="p">.</span><span class="nf">to_s</span> <span class="k">if</span> <span class="n">font</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">pointsize</span> <span class="o">=</span> <span class="n">size</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">font_weight</span> <span class="o">=</span> <span class="n">font_weight</span>
      <span class="c1"># @text.gravity = GRAVITY_MEASURE[gravity] || Magick::ForgetGravity</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">stroke</span> <span class="n">stroke</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">stroke_antialias</span> <span class="kp">false</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">text_antialias</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="n">modify_draw</span><span class="p">(</span><span class="vi">@text</span><span class="p">,</span> <span class="ss">x_shift: </span><span class="n">x</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="ss">y_shift: </span><span class="n">y</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="ss">rotation: </span><span class="n">rotation</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">draw</span><span class="o">|</span>
        <span class="n">draw</span><span class="p">.</span><span class="nf">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">text</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="s1">'%'</span><span class="p">,</span> <span class="s1">'%%'</span><span class="p">))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Apart from the self-explanatory, the other variables are <em>font_weight</em> which represents Magickâ€™s weight properties(currently not used), <em>halign</em> and <em>valign</em> whcih represent horizontal and vertical alignments respectively, rotation if the text is to be rotated and the stroke which defines the pattern for the text (does not make a difference currently) and the absolute flag as abs.<br/> This function first checks whether the text argument is given or not and only proceeds if it is given. Next, the <strong>within_window</strong> function is called which sets up the area (the window) in which the drawing is to be done. This function takes a block as input which is just a collection of lines of code to be executed. The function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_window</span><span class="p">(</span><span class="n">abs</span><span class="o">=</span><span class="kp">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">abs</span>
    <span class="c1"># Coordinates are given in rubyplot cordinates</span>
    <span class="c1"># Transform function handles deciding the position</span>
    <span class="c1"># in the figure</span>
    <span class="k">yield</span>
  <span class="k">else</span>
    <span class="c1"># Coordinates are not in rubyplot coordinates</span>
    <span class="c1"># Shifting to adjust incorporate the margin of the figure and axes</span>
    <span class="c1"># border! method can be used for figure margin but that will disturb rubyplot coordinates</span>
    <span class="c1"># i.e. rubyplot coordinates include the border spacing</span>
    <span class="n">x_shift</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">abs_x</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">left_margin</span><span class="p">)</span> <span class="o">*</span> <span class="vi">@canvas_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="c1"># in pixels</span>
    <span class="n">y_shift</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">abs_y</span> <span class="o">-</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">bottom_spacing</span> <span class="o">+</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">top_spacing</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">top_margin</span><span class="p">)</span> <span class="o">*</span> <span class="vi">@canvas_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="c1"># in pixels</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span>

    <span class="n">plottable_width</span> <span class="o">=</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">width</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">left_margin</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">right_margin</span><span class="p">)</span>
    <span class="n">plottable_height</span> <span class="o">=</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">height</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">bottom_margin</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">top_margin</span><span class="p">)</span>
    <span class="c1"># Scaling</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">,</span> <span class="n">plottable_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">,</span> <span class="n">plottable_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">,</span> <span class="n">plottable_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">)</span>

    <span class="c1"># Calling the block</span>
    <span class="k">yield</span>

    <span class="c1"># Rescaling</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="o">/</span> <span class="n">plottable_width</span><span class="p">,</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="o">/</span> <span class="n">plottable_height</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="o">/</span> <span class="n">plottable_width</span><span class="p">,</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="o">/</span> <span class="n">plottable_height</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="o">/</span> <span class="n">plottable_width</span><span class="p">,</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="o">/</span> <span class="n">plottable_height</span><span class="p">)</span>

    <span class="c1"># Reshifting to the original coordinates</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first checks the absolute flag and does nothing if it is true(as the coordinates are absolute and no shifting is required), if the absolute flag is false then the data used for drawing is in plot coordinates i.e. according to the data given by the user for the plot. So, if abs = false then there is a need to incorporate the margins for the figure as well as for the subplot and so the origin (upper left corner in magick) is shifted accordingly using Magickâ€™s <strong>translate</strong> function which takes input as the amount(in pixels) by which X and Y origin is to be shifted, here we are not actually shifting the canvas but instead just the origin of the three Magick::Draw objects <em>draw</em>, <em>text, *axes</em> which actually draw shapes/text/axes on the canvas.<br/> So, the amount by which the objects are to be shifted is to be given in pixels as Magick only accepts pixels and hence the coordinates present in Rubyplot coordinates are first divided by the maximum Rubyplot coordinate to bring the coordinate in the range [0,1] and then it is multiplied by the <em>canvas_width</em> to finally convert the coordinate into pixel value (remember the <em>canvas_width</em> was already scaled according to the <em>figsize_unit</em>). A similar operation is done for Y coordinate with a change that <em>top_margin</em> is incorporated as the origin for Magick backend is the upper left corner.</p> <p>After translation, scaling is done using <strong>scale</strong> function of Magick::Draw object which takes input the factor by which X and Y coordinates are to be scaled. This ensures that the drawing is scaled according to the requirements.</p> <p>After translation and scaling, the block is executed and the Draw object return to their original state by scaling and translating to the original state in which the Draw objects were present.</p> <p>After the <strong>within_window</strong> function, the X and Y coordinates are transformed to convert them into pixel values to be used further using the functions <strong>transform_x</strong> and <strong>transform_y</strong> which take the inputs, the coordinate to be transformed and the absolute flag. These functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Transform X co-ordinate.</span>
<span class="k">def</span> <span class="nf">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">abs</span>
    <span class="p">(</span><span class="vi">@canvas_width</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">*</span> <span class="n">x</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="p">((</span><span class="n">x</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">-</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">to_f</span> <span class="o">-</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_f</span><span class="p">))</span> <span class="o">*</span> <span class="vi">@canvas_width</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Transform Y co-ordinate</span>
<span class="k">def</span> <span class="nf">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">abs</span>
    <span class="p">(</span><span class="vi">@canvas_height</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">*</span> <span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">-</span> <span class="n">y</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="p">((</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">to_f</span> <span class="o">-</span> <span class="n">y</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">to_f</span> <span class="o">-</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_f</span><span class="p">))</span> <span class="o">*</span> <span class="vi">@canvas_height</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>In these functions, if the absolute flag is true i.e. the coordinates are in Rubyplot coordinates then similar to <strong>within_window</strong> function, the coordinates are first brought to the range [0,1] and then multiplied by the canvas dimensions to get the coordinates in pixels. The difference in Y coordinate is that in Magick the origin is the upper left corner but we want to make the origin as lower left corner and so the minimum Rubyplot coordinate actually refers to the highest point in the Figure and so we want to flip the position of points vertically and hence the coordinate is first subtracted from the maximum Rubyplot coordinates so that we get the desired plot.<br/> Next, if the absolute flag is false i.e. the coordinates are not in Rubyplot coordinates and are according to the plot, the coordinate is brought to a range [0,1] by using minimum and maximum values of the data. And notice that similar to abs = true, the Y coordinate is scaled so that the position of points is flipped vertically. The <strong>x_range</strong> and <strong>y_range</strong> functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">x_range</span>
  <span class="p">[</span><span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">,</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">y_range</span>
  <span class="p">[</span><span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">,</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div> <p>These functions return the maximum and minimum values of X and Y axes across all the plots.</p> <p>After these functions, the useful properties for <em>text</em> variable is set for drawing. Also, the <em>color</em> variable which stores the symbol for the colour is converted to its RGB value which is stored in the <em>COLOR_INDEX</em> hash present in Color module. Next, the font is set if present, then <strong>pointsize</strong> function sets the size of the text in points unit. Then after setting the remaining useful properties, the text is to be drawn in the <em>text</em> variable which is a Magick::Draw object. But before that the <strong>modify_draw</strong> function is called which modifies a Magick::Draw object (or an array of such objects) for a temporary period until the block which is given as the input is executed, it takes in the inputs as the Magick::Draw object (or an array of such objects) which is to be modified, the amount of X and Y shift in pixels and the rotation. The function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">modify_draw</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="ss">x_shift: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">y_shift: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">scale_x: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">scale_y: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">rotation: </span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">draw</span> <span class="o">=</span> <span class="p">[</span><span class="n">draw</span><span class="p">]</span> <span class="k">unless</span> <span class="n">draw</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:each</span> <span class="c1"># Making draw iterable if not iterable</span>
  <span class="n">draw</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_shift</span> <span class="o">&amp;&amp;</span> <span class="n">y_shift</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">rotate</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="k">if</span> <span class="n">rotation</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">)</span> <span class="k">if</span> <span class="n">scale_x</span> <span class="o">&amp;&amp;</span> <span class="n">scale_y</span>
  <span class="k">end</span>

  <span class="n">draw</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span>
    <span class="k">yield</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">draw</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">scale_x</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">scale_y</span><span class="p">)</span> <span class="k">if</span> <span class="n">scale_x</span> <span class="o">&amp;&amp;</span> <span class="n">scale_y</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">rotate</span><span class="p">(</span><span class="mf">90.0</span><span class="p">)</span> <span class="k">if</span> <span class="n">rotation</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_shift</span> <span class="o">&amp;&amp;</span> <span class="n">y_shift</span>
  <span class="k">end</span>
  <span class="n">draw</span> <span class="o">=</span> <span class="n">draw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">unless</span> <span class="n">draw</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:each</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first makes the <em>draw</em> local variable iterable if it is not an array, then for each iten in the array it translates, scales and rotates the Draw object, then it executes the block and then returns the Draw object to its original state.<br/> One important thing to keep in mind is that the Draw object is rotated with respect to its origin.</p> <p>So, we call the <strong>modify_draw</strong> function and then use the <strong>text</strong> of the Magick::Draw object to create a text on the required point. Here, we used the <strong>modify_draw</strong> function because we wanted to rotate the text correctly. So, first we translated the Magick::Draw objectâ€™s origin to where the text is to be drawn then we rotated the object with respect to the point where the text is to be drawn and then we drew the text at the point 0,0 which is actually the point where text is to be drawn as the origin of the Magick::Draw object is the point where the text was to be drawn.<br/> Also, in the string <em>text</em> the â€˜%â€™ is replaced with â€˜%%â€™ using the <strong>gsub</strong> function so that Ruby does not interpret â€˜%â€™ as a keyword.</p> <p>So, now the <strong>draw</strong> function of the X and Y axis has been executed and we return to <strong>draw</strong> function of the subplot i.e. the axes.</p> <p>The next command is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
</code></pre></div></div> <p>which works in a similar way as described above (in <strong>draw</strong> of X and Y axes).</p> <p>Next, the code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@legend_box</span><span class="p">.</span><span class="nf">draw</span>
</code></pre></div></div> <p>which calls the <strong>draw</strong> function for <em>legend_box</em>:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="k">unless</span> <span class="vi">@legends</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@bounding_box</span><span class="p">.</span><span class="nf">draw</span>
    <span class="vi">@legends</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function only proceeds when there is at least one Legend object is present in <em>legends</em> array. If <em>legends</em> array is not empty then first the <strong>draw</strong> function is called for <em>bounding_box</em> which is actually a Rectangle object whose <strong>draw</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_rectangle</span><span class="p">(</span>
    <span class="ss">x1: </span><span class="vi">@x1</span><span class="p">,</span>
    <span class="ss">y1: </span><span class="vi">@y1</span><span class="p">,</span>
    <span class="ss">x2: </span><span class="vi">@x2</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="vi">@y2</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@border_color</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@fill_color</span><span class="p">,</span>
    <span class="ss">abs: </span><span class="vi">@abs</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>which simply calls the <strong>draw_rectangle</strong> function of the backend and the inputs given to it are the x,y coordinates of the lower left and upper right corners, the colour of the border and the colour to be filled in the rectangle and finally the absolute flag (which is true here).<br/> The <strong>draw_rectangle</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_rectangle</span><span class="p">(</span><span class="n">x1</span><span class="p">:,</span><span class="n">y1</span><span class="p">:,</span><span class="n">x2</span><span class="p">:,</span><span class="n">y2</span><span class="p">:,</span> <span class="ss">border_color: :default</span><span class="p">,</span>
        <span class="ss">fill_color: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">border_width: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">border_type: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="n">within_window</span><span class="p">(</span><span class="n">abs</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x1</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x2</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y1</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y2</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>

    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span> <span class="k">if</span> <span class="n">fill_color</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke_width</span> <span class="n">border_width</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="c1"># if fill_color is not given, the rectangle fill colour is transparent</span>
    <span class="c1"># i.e. only edges are visible</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="mi">0</span> <span class="k">unless</span> <span class="n">fill_color</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">rectangle</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="mi">1</span> <span class="k">unless</span> <span class="n">fill_color</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here, first <strong>within_window</strong> is called which works the same as explained before, then the coordinates are transformed using <strong>transform_x</strong> and <strong>transform_y</strong> which work the same as explained before. Then the colour of the border and the colour to be filled are set using the <strong>stroke</strong> and <strong>fill</strong> functions of Magick::Draw respectively. The <em>COLOR_INDEX</em> hash is used to provide the colour in the correct format. Then the border width is set using <strong>stroke_width</strong> function. Then opacity is set to 0 if no colour is to be filled i.e. <em>fill_color</em> is not given i.e. it is nil. Finally, the <strong>rectangle</strong> function is called which takes in two opposite corners and draws the rectangle. And then the opacity is returned to 1 i.e. its original state.<br/> P.S. - The rectangle is drawn in <em>draw</em> variable and the text was drawn in <em>text</em> variable.</p> <p>Now, the <strong>draw</strong> function for each Legend object is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="vi">@legend_color_box</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@text</span><span class="p">.</span><span class="nf">draw</span>
<span class="k">end</span>
</code></pre></div></div> <p>In this function, the <em>legend_color_box</em> and <em>text</em> call their <strong>draw</strong> function which is actually Rectangle and Text objects. We have already discussed the explanation for drawing these objects.</p> <h3 id="drawing-plots">Drawing plots</h3> <p>Returning to the <strong>draw</strong> function of the axes, the final line of code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@plots</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
</code></pre></div></div> <p>The <strong>draw</strong> function for each plot in <em>plots</em> array is called. In this example we have only one plot which is the scatter plot i.e. a Scatter object and hence the <strong>draw</strong> function of Scatter is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_markers</span><span class="p">(</span>
    <span class="ss">x: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">],</span>
    <span class="ss">y: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">],</span>
    <span class="ss">type: </span><span class="vi">@marker_type</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@marker_fill_color</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@marker_border_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="p">[</span><span class="vi">@marker_size</span><span class="p">]</span> <span class="o">*</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">size</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>which simply calls the backend function <strong>draw_markers</strong> and the inputs given to it are the arrays containing the X and the Y data, the type of marker to be drawn, the colour to be filled in the marker and the border and finally an array of sizes of the markers(the size for all the markers is kept same). The <strong>draw_markers</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_markers</span><span class="p">(</span><span class="n">x</span><span class="p">:,</span> <span class="n">y</span><span class="p">:,</span> <span class="ss">type: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">fill_color: :default</span><span class="p">,</span> <span class="ss">border_color: :default</span><span class="p">,</span> <span class="ss">size: </span><span class="kp">nil</span><span class="p">)</span>
  <span class="n">y</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">iy</span><span class="p">,</span> <span class="n">idx_y</span><span class="o">|</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x</span><span class="p">[</span><span class="n">idx_y</span><span class="p">],</span><span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">iy</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="c1"># in GR backend size is multiplied by</span>
    <span class="c1"># nominal size generated on the graphics device</span>
    <span class="c1"># so setting the nominal_factor</span>
    <span class="n">nominal_factor</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">within_window</span> <span class="k">do</span>
      <span class="n">size</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">*=</span> <span class="n">nominal_factor</span>
      <span class="no">MARKER_TYPES</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="nf">call</span><span class="p">(</span><span class="vi">@draw</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">[</span><span class="n">idx_y</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>In this function for each entry in the data (same for X or Y) a marker is drawn, so a loop is executed in which for each entry first the X and Y coordinates are transformed using <strong>transform_x</strong> and <strong>transform_y</strong> functions (explained earlier). Then the size is multiplied by a <em>nominal_factor</em> to make the backends consistent. In GR backend, the size is multiplied by the nominal size generated on the graphics device(the value is not disclosed) and so for Magick backend <em>nominal_factor</em> is chosen as 15 (found through trial and error by comparing the same figures for both backends). Now, the <strong>within_window</strong> function is called (explained earlier) and size is multiplied by the <em>nominal_factor</em>. Then the marker is drawn in the <em>draw</em> object using the <em>MARKER_TYPES</em> which stores lambdas for drawing the markers and so according to the <em>type</em> the lambda stored in <em>MARKER_TYPES</em> is called using <strong>call</strong>. Each of the Lambda takes in input the Magick::Draw object, the x,y coordinates (in pixels), the colour to be filled, the border colour and the size of the marker.</p> <p>In this example, the types of the marker is <em>:circle</em> and the Lambda for it is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MARKER_TYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1"># Default type is circle</span>
  <span class="c1"># Stroke width is set to 1</span>
  <span class="ss">nil: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">circle: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="c1"># Code for rest of the markers is not shown because of space constraints</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <em>:circle</em> Lambda first sets the colour of the border and the colour to be filled and then it calls the <strong>circle</strong> function for the Magick::Draw object stored in <em>draw</em> local variable to draw a circle. The function takes in inputs as the x,y coordinates for the centre and a point at the circumference (in pixel values). So, the marker is drawn in the <em>draw</em> variable.</p> <p>We now return to the <strong>write</strong> function of the Figure.</p> <h3 id="writing-figure-backend">Writing Figure (Backend)</h3> <p>Now, the <strong>write</strong> function of the backend is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write</span>
  <span class="n">draw_axes</span>
  <span class="vi">@draw</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="vi">@text</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="vi">@base_image</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="vi">@file_name</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first calls the <strong>draw_axes</strong> which will draw the <em>axes</em> Magick::Draw object onto the Magick::Image object <em>base_image</em> which is the canvas. Then the <strong>draw</strong> function is called for the Magick::Draw objects <em>draw</em> and <em>text</em> and the input is given is <em>base_image</em>, so the Magick::Draw objects are drawn onto the canvas i.e. Magick::Image object. And finally, the <strong>write</strong> function is called for <em>base_image</em> which is a Magick::Image, the function takes the input a string which would be the name of the file(image) when saved and so the <em>base_image</em> is written onto the device.<br/> The <strong>draw_axes</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_axes</span>
  <span class="vi">@axes_map</span><span class="p">.</span><span class="nf">each_value</span> <span class="k">do</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="ss">:axes</span><span class="p">]</span>
    <span class="vi">@active_axes</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="n">within_window</span> <span class="k">do</span>
      <span class="c1"># Plot the X and Y axes</span>
      <span class="vi">@axes</span><span class="p">.</span><span class="nf">polyline</span><span class="p">(</span>
        <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">v</span><span class="p">[</span><span class="ss">:x_origin</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">v</span><span class="p">[</span><span class="ss">:y_origin</span><span class="p">]),</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">v</span><span class="p">[</span><span class="ss">:y_origin</span><span class="p">]),</span>
        <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">v</span><span class="p">[</span><span class="ss">:x_origin</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">v</span><span class="p">[</span><span class="ss">:y_origin</span><span class="p">]),</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">v</span><span class="p">[</span><span class="ss">:x_origin</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="vi">@axes</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function is used to draw the X and Y axis using the <em>axes_map</em> hash. Now, for every key in the <em>axes_map</em> hash first the <em>axes</em> variable is set as the subplot(axes) for which the X and Y axes is to be drawn, then the <em>active_axes</em> is set as the subplot. Then the <strong>within_window</strong> function is called (explained earlier) and then the <strong>polyline</strong> function is called for <em>axes</em> magick::Draw object which draws multiple line by taking the inputs as multiple x,y coordinate pairs for starting and ending points of the lines (in pixels). So, the inputs given to draw the X axis are the transformed points origin of the <em>axes</em> and the maximum value of X, Y origin. For the Y axis, the inputs given are the transformed points origin of the <em>axes</em> and the X origin, maximum value of Y.</p> <p>Finally, the <em>axes</em> Magick::Draw object is drawn using the <strong>draw</strong> function on the <em>base_image</em> Magick::image object (canvas).</p> <p>We now return to the <strong>write</strong> function of the Figure to execute the last line of code. Notice that we have already drawn and saved the figure.</p> <h2 id="finishing-up">Finishing up</h2> <p>Finally the backendâ€™s <strong>stop_output_device</strong> function is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stop_output_device</span>
  <span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span> <span class="o">=</span> <span class="n">unscale_figure</span><span class="p">(</span><span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span><span class="p">)</span>
  <span class="n">flush</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first scales the canvas dimensions to its original values by calling <strong>unscale_figure</strong> which were scaled according to the <em>figsize_units</em> variable. Then the <strong>flush</strong> function is called which clears the memory by disposing of data which is no longer useful.</p> <p>The <strong>unscale_figure</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">unscale_figure</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
  <span class="p">[</span><span class="n">width</span> <span class="o">/</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">],</span> <span class="n">height</span> <span class="o">/</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">]]</span>
<span class="k">end</span>
</code></pre></div></div> <p>The width and the height are divided by the conversion constants set in the <em>PIXEL_MULTIPLIERS</em> hash (explained earlier). So, the Figure dimensions are scaled back to its original values.</p> <p>The <strong>flush</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Refresh this backend and remove all previously set data.</span>
<span class="k">def</span> <span class="nf">flush</span>
  <span class="vi">@axes_map</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div> <p>First the <em>axes_map</em> is cleared and then the <em>file_name</em> is cleared. This refreshes the backend and clears the memory.</p> <p><strong>So, we have finally drawn, written and saved our figure.</strong></p>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: Explaining the scatter plot example.]]></summary></entry><entry><title type="html">Rubyplot installation guide</title><link href="https://alishdipani.github.io/gsoc2019/2019/06/09/Rubyplot-installation-guide/" rel="alternate" type="text/html" title="Rubyplot installation guide"/><published>2019-06-09T12:00:00+00:00</published><updated>2019-06-09T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/06/09/Rubyplot-installation-guide</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/06/09/Rubyplot-installation-guide/"><![CDATA[<p>Summary: Installation guide for Rubyplot.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#installation" id="markdown-toc-installation">Installation</a></li> <li><a href="#testing" id="markdown-toc-testing">Testing</a> <ul> <li><a href="#running-all-tests-at-once" id="markdown-toc-running-all-tests-at-once">Running all tests at once</a></li> <li><a href="#running-specific-tests" id="markdown-toc-running-specific-tests">Running specific tests</a></li> </ul> </li> <li><a href="#refrences" id="markdown-toc-refrences">Refrences</a></li> </ul> <h1 id="introduction">Introduction</h1> <p>This blog is a guide for Developer installation of Rubyplot and testing including both GR and ImageMagick backends.</p> <h1 id="installation">Installation</h1> <p>P.S.- Make sure you have installed Ruby and have updated it to the latest version.</p> <p>Installation steps:</p> <ol> <li>Installing GR C Framework: Follow the instructions given <a href="https://software.opensuse.org/download.html?project=science:gr-framework&amp;package=python-gr">[here]</a> but change the command to sudo apt-get install gr (instead of sudo apt-get install python-gr).<br/> GR will be installed in the path : <code class="language-plaintext highlighter-rouge">/usr/gr</code></li> <li>Create a symbolic link for GR in the path <code class="language-plaintext highlighter-rouge">/usr/local/gr</code> using this command: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo ln</span> <span class="nt">-s</span> /usr/gr /usr/local/gr
</code></pre></div> </div> </li> <li>Clone the Rubyplot repository using this command: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/SciRuby/rubyplot.git
</code></pre></div> </div> </li> <li>Change the current directory to Rubyplot folder by using this command: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>rubyplot
</code></pre></div> </div> </li> <li>Now set the important environment variables by running this command: <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">GRDIR</span><span class="o">=</span><span class="s2">"/usr/local/gr"</span>
<span class="nb">export </span><span class="nv">GKS_FONTPATH</span><span class="o">=</span><span class="s2">"/usr/local/gr"</span>
<span class="nb">export </span><span class="nv">RUBYPLOT_BACKEND</span><span class="o">=</span><span class="s2">"GR"</span>
</code></pre></div> </div> <p>Alternatively you can set <code class="language-plaintext highlighter-rouge">GRDIR</code> and <code class="language-plaintext highlighter-rouge">GKS_FONTPATH</code> to the path where GR is installed if itâ€™s different.<br/> We have set the Rubyplot backend to GR.</p> </li> <li>Replace line 3 and 4 in <code class="language-plaintext highlighter-rouge">ext/grruby/extconf.rb</code> by these lines: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$CFLAGS &lt;&lt; ' -I/usr/local/gr/include '
$LDFLAGS &lt;&lt; ' -L/usr/local/gr/lib -lGR -lm -Wl,-rpath,/usr/local/gr/lib '
</code></pre></div> </div> <p>Or change it to the path where GR is present if different.</p> </li> <li>Change lines 13 and 14 in <code class="language-plaintext highlighter-rouge">spec/spec_helper.rb</code> to this: <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ENV['GRDIR'] = "/usr/local/gr"
ENV['GKS_FONTPATH'] = "/usr/local/gr"
</code></pre></div> </div> <p>Or change it to the path where GR is present if different.</p> </li> <li>Run these commands: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>gem <span class="nb">install </span>bundler
bundle <span class="nb">install
</span>rake compile
</code></pre></div> </div> <p>GR backend has been setup, now we need to set up the ImageMagick backend.</p> </li> <li>To install ImageMagick and rmagick follow the instructions <a href="https://github.com/rmagick/rmagick">[here]</a>.</li> <li>Now, we have setup both the backends and can change the backends at any time using this command: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">RUBYPLOT_BACKEND</span><span class="o">=</span><span class="s2">"GR"</span> <span class="c"># For GR backend</span>
<span class="nb">export </span><span class="nv">RUBYPLOT_BACKEND</span><span class="o">=</span><span class="s2">"MAGICK"</span> <span class="c"># For ImageMagick backend</span>
</code></pre></div> </div> </li> </ol> <h1 id="testing">Testing</h1> <h2 id="running-all-tests-at-once">Running all tests at once</h2> <p>To run all the tests at once, run this command in the rubyplot folder:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rspec
</code></pre></div></div> <h2 id="running-specific-tests">Running specific tests</h2> <p>For running specific tests follow these instructions:</p> <ol> <li>Make sure you are in the rubyplot folder.</li> <li>Change the backend to desired one by following step 10 of Installation.</li> <li>Tests related to specific plots are present in <code class="language-plaintext highlighter-rouge">spec/axes_spec.rb</code> and tests general tests are present in <code class="language-plaintext highlighter-rouge">spec/figure_sprc.rb</code>.</li> <li>Append <code class="language-plaintext highlighter-rouge">,focus:true</code> in front of the test(s) which you want to run, for example, the bubble plot tests are: <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">context</span> <span class="s2">"#bubble!"</span> <span class="k">do</span>
 <span class="n">it</span> <span class="s2">"plots a single bubble plot"</span> <span class="k">do</span>
   <span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
   <span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">bubble!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"apples"</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:blue</span>
   <span class="k">end</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">x_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">y_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"simple bubble plot."</span>
 <span class="k">end</span>

 <span class="n">it</span> <span class="s2">"plots multiple bubble plots on same axes."</span> <span class="k">do</span> 
   <span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
   <span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">bubble!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"apples"</span>
   <span class="k">end</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">bubble!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mf">10.3</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"peaches"</span>
   <span class="k">end</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"simple bubble plot."</span>
 <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> </div> <p>Append <code class="language-plaintext highlighter-rouge">,focus:true</code> in front of <code class="language-plaintext highlighter-rouge">context "#bubble!"</code> if you want to run every test in the context of bubble plot.<br/> Or append <code class="language-plaintext highlighter-rouge">,focus:true</code> in front of any test which you want to run, for example, in front of <code class="language-plaintext highlighter-rouge">it "plots a single bubble plot"</code>.<br/> An example for appended code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">context</span> <span class="s2">"#bubble!"</span><span class="p">,</span><span class="n">focus</span><span class="ss">:true</span> <span class="k">do</span>
 <span class="n">it</span> <span class="s2">"plots a single bubble plot"</span><span class="p">,</span><span class="n">focus</span><span class="ss">:true</span> <span class="k">do</span>
   <span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
   <span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">bubble!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"apples"</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="ss">:blue</span>
   <span class="k">end</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">x_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">y_range</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"simple bubble plot."</span>
 <span class="k">end</span>

 <span class="n">it</span> <span class="s2">"plots multiple bubble plots on same axes."</span><span class="p">,</span><span class="n">focus</span><span class="ss">:true</span> <span class="k">do</span> 
   <span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span>
   <span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">bubble!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">23</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">35</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"apples"</span>
   <span class="k">end</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">bubble!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">27</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mf">10.3</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
     <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"peaches"</span>
   <span class="k">end</span>
   <span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"simple bubble plot."</span>
 <span class="k">end</span>
<span class="k">end</span>
</code></pre></div> </div> <p>Append it in front of all tests which you want to run.</p> </li> <li>Run this command: <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rspec <span class="nt">--t</span><span class="o">=</span>focus<span class="sb">`</span>
</code></pre></div> </div> </li> </ol> <h1 id="refrences">Refrences</h1> <ol> <li><a href="https://github.com/pgtgrly/GRruby-extension">GRRuby</a></li> <li><a href="https://github.com/SciRuby/rubyplot">Rubyplot</a></li> <li><a href="https://rmagick.github.io/">Rmagick</a></li> <li><a href="https://gr-framework.org/">GR</a></li> </ol>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: Installation guide for Rubyplot.]]></summary></entry><entry><title type="html">GSoC 2019 project introduction</title><link href="https://alishdipani.github.io/gsoc2019/2019/06/08/GSoC-2019-project-introduction/" rel="alternate" type="text/html" title="GSoC 2019 project introduction"/><published>2019-06-08T12:00:00+00:00</published><updated>2019-06-08T12:00:00+00:00</updated><id>https://alishdipani.github.io/gsoc2019/2019/06/08/GSoC-2019-project-introduction</id><content type="html" xml:base="https://alishdipani.github.io/gsoc2019/2019/06/08/GSoC-2019-project-introduction/"><![CDATA[<p>Summary: Introducing my project for GSoC 2019.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#what-is-rubyplot" id="markdown-toc-what-is-rubyplot">What is Rubyplot?</a></li> <li><a href="#how-does-rubyplot-work" id="markdown-toc-how-does-rubyplot-work">How does Rubyplot work?</a> <ul> <li><a href="#an-example-code" id="markdown-toc-an-example-code">An Example Code</a></li> </ul> </li> <li><a href="#my-project" id="markdown-toc-my-project">My Project</a></li> <li><a href="#ending-note" id="markdown-toc-ending-note">Ending Note</a></li> </ul> <h1 id="introduction">Introduction</h1> <p>Google Summer of Code (GSoC) is a prestigious global program which aims to bring more student developers into open source software development. This program is for 3 months during the summers.</p> <p>In order to improve my software development skills and to get myself familiarised with open source software development, I applied for GSoC 2019 with two organisations - <strong>Biomedical Informatics, Emory University</strong> and <strong>Ruby Science Foundation</strong>. Thankfully, I was selected for GSoC 2019 with Ruby Science Foundation to work on the plotting library Rubyplot. This is the first of many blogs which I will be writing for my project. This first blog is an introduction to Rubyplot, my project and what to expect at the end of GSoC 2019. Stay tuned for more blogs :)</p> <p>P.S. - My proposals can be found here :</p> <ol> <li>Biomedical Informatics, Emory University <a href="https://docs.google.com/document/d/1wGPSaHtE7v-tGWbXaIkxzNwbvQ6cCp0R5lxFxI0JGak/edit?usp=sharing">[Link]</a></li> <li>Ruby Science Foundation <a href="https://docs.google.com/document/d/1UoAE2MQ0l67ZZ0UWjykmRZnCHO_u22FM2zlHfVYUyEQ/edit?usp=sharing">[Link]</a> (Up-to-date proposal <a href="https://github.com/alishdipani/rubyplot/wiki/GSoC-2019-Proposal">[Link]</a>)</li> </ol> <h1 id="what-is-rubyplot">What is Rubyplot?</h1> <p>RubyPlot is a plotting library in Ruby for scientific development inspired by the library Matplotlib for Python. Users can create various types of plots like scatter plot, bar plot, etc. and can also create subplots which combine various of these plots. The long-term goal of the library is to build an efficient, scalable and user-friendly library with a backend-agnostic frontend to support various backends so that the library can be used on any device.<br/> Currently, Rubyplot supports only GR backend and a limited number of plots.</p> <h1 id="how-does-rubyplot-work">How does Rubyplot work?</h1> <p>To give an overview of how does Rubyplot work, suppose you have a canvas(figure in Rubyplot) and you want to draw 4 paintings(subplots in Rubyplot which is an axes) on the canvas in a way that canvas area is divided into 4 equal squares and so in your mind you divide the canvas space into four parts(axes coordinates for each axes object are decided in Rubyplot). Now, you start to think about a painting(suppose, the first painting out of 4 paintings) and itâ€™s type like for example a still-life figure or a scenery, etc. (different plots in Rubyplot like scatter plot, bar plot, etc.) and so you fix the type of painting in your mind(specifying the type of plot in the axes object). After fixing the type you think about what all things will be in that painting(properties of a plot, for example, data-points, marker size and marker colour in a scatter plot). After fixing one painting you move on to think about the rest and you fix the contents of all those paintings too.<br/> Till now you have fixed what all will be in the paintings and have not actually drawn anything(write (save) in Rubyplot).<br/> Now, you draw the painting(call write in Rubyplot)(in Rubyplot when write is called everything is drawn on the corresponding area including shapes, text, X and Y axis,etc.).</p> <h2 id="an-example-code">An Example Code</h2> <p>An example code to create a scatter plot would be:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'Rubyplot'</span>
<span class="vi">@xdata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1"># Defining X data</span>
<span class="vi">@ydata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">65</span><span class="p">]</span> <span class="c1"># Defining Y data</span>
<span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># Creating the canvas</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="c1"># Adding a subplot (0,0 as only one subplot is to be plotted)</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">scatter!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="c1"># Setting scatter as the type of subplot</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Nice plot"</span> <span class="c1"># defining title of the plot</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_title</span> <span class="o">=</span> <span class="s2">"X data"</span> <span class="c1"># defining title of X axis</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_title</span> <span class="o">=</span> <span class="s2">"Y data"</span> <span class="c1"># defining title of Y axis</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"scatterplot.png"</span><span class="p">)</span> <span class="c1"># Drawing the figure and saving it</span>
</code></pre></div></div> <p>The output of this is for GR backend is:<br/> <img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/GSoC_2019_project_introduction/scatter_GR.png" width="600"/><br/> The output of this is for Magick backend is:<br/> <img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/GSoC_2019_project_introduction/scatter_Magick.png" width="600"/></p> <p>P.S. - The version of the library used to run this code is of the date 9 June and Magick backend was not supported at the time of the start of my project.<br/> So currently, Rubyplot supports GR fully and Magick backend partially(notice the ticks on axes are not implemented).</p> <h1 id="my-project">My Project</h1> <p>My project is to add Magick backend and additional functionalities to Rubyplot. The outcomes of my project would be :</p> <ol> <li><strong>ImageMagick support</strong>: Support for ImageMagick back-end will be added in addition to the currently supported back-end GR, the front-end of the library will be back-end agnostic and the current overall integrity of the library will be preserved.</li> <li><strong>Plotting and show function</strong>: A new <strong>plot</strong> function will be added which plots markers (for example circles) to form a scatter plot with the points as inputs (same as plot function in Matplotlib). A new function <strong>show</strong> will be added which will allow viewing of a plot without saving it. This plot function will be back-end agnostic and hence will support both GR and Magick back-end.</li> <li><strong>Integration with iruby notebooks</strong>: Rubyplot will be integrated with iruby notebooks supporting all backends and allowing inline plotting.</li> </ol> <h1 id="ending-note">Ending Note</h1> <p>More details about my project and implementation details can be found in my up-to-date proposal <a href="https://github.com/alishdipani/rubyplot/wiki/GSoC-2019-Proposal">[Link]</a></p> <p>Stay tuned for more blogs with more technical depth and challenges which I faced during the project :)</p>]]></content><author><name></name></author><category term="gsoc2019,"/><category term="rubyplot"/><summary type="html"><![CDATA[Summary: Introducing my project for GSoC 2019.]]></summary></entry><entry><title type="html">Neural Style Transfer on Audio Signals</title><link href="https://alishdipani.github.io/projects/2018/08/Neural-Style-Transfer-Audio/" rel="alternate" type="text/html" title="Neural Style Transfer on Audio Signals"/><published>2018-08-29T12:00:00+00:00</published><updated>2018-08-29T12:00:00+00:00</updated><id>https://alishdipani.github.io/projects/2018/08/Neural-Style-Transfer-Audio</id><content type="html" xml:base="https://alishdipani.github.io/projects/2018/08/Neural-Style-Transfer-Audio/"><![CDATA[<p>Summary: Generation of new music using Neural Style Transfer Algorithm.</p> <h1 id="introduction"><ins>Introduction</ins></h1> <p>â€œStyle Transferâ€ on images has recently become very popular and an active research topic, this shows how Convolutional Neural Networks(CNNs) have the power to adapt to a great variety of tasks. Here, we extend and modify this algorithm for audio signals and use the power of CNNs and generate new audio from a style audio that can be the tune or the beat and a content audio that can be someone just speaking the lyrics of a song.</p> <h1 id="neural-style-transfer-on-images"><ins>Neural Style Transfer on Images</ins></h1> <p>â€œNeural Style Transferâ€ was originally for images, the idea is to use a CNN model for extracting the style of an image called style image and content of another image called content image and generating a new image having the style of the style image and content of the content image. This is done by encoding the two images using a CNN Model and then taking a white noise image and minimizing the loss between this image and content and style images so that it has the content same as the content image and style as style image. <br/><br/> Let \(\vec{p}\) be the content image, \(\vec{a}\) be the style image and \(\vec{x}\) be the white noise image (i.e. the generated image) which will be the final image.<br/> So, total loss is sum of content loss and style loss.<br/> \(L_{total}(\vec{p},\vec{a},\vec{x}) = \alpha L_{content}(\vec{p},\vec{x}) + \beta L_{style}(\vec{a},\vec{x})\)</p> <h3 id="cnn-model">CNN Model</h3> <p>A deep CNN model is chosen to extract the features of images. Deep CNN models provide proper encoding for the features of images. A Model like VGG-19 is chosen having a large number of convolutional layers. Pre-trained model is used as they provide proper encoding.</p> <p><img src="https://www.pyimagesearch.com/wp-content/uploads/2018/08/neural_style_transfer_gatys.jpg" alt="alt text"/></p> <h3 id="content-loss">Content Loss</h3> <p>The content loss is the Mean squared error between the encoding of the white noise image and the content image.<br/> For a layer \(l\) and the input image \(\vec{x}\), let the number of filters be \(N_{l}\) and so the output(or encoded) image will have \(N_{l}\) feature maps, each of size \(M_{l}\), where \(M_{l}\) is the height times width. So, the encoded image of layer can be stored in a matrix \(F_{l} \epsilon R^{ N_{l}xM_{l} }\). Where \(F^{l}_{ij}\) is the activation of \(i^{th}\) filter at position \(j\) in layer \(l\).<br/> \(L_{content}(\vec{p},\vec{x},l) = \frac{1}{2} \sum_{i,j}(F^{l}_{ij} - P^{l}_{ij})^{2}\)</p> <h3 id="style-loss">Style Loss</h3> <p>For capturing the style a style representation is used which computer the correlations between the different filter responses, where the expectation is taken over the spatial extent of the input image. These feature correlations are given by Gram Matrix \(G^{l} \epsilon R^{ N_{l}xN_{l} }\), where \(G^{l}_{ij}\) is the inner product between the feature maps \(i\) and \(j\) represented by vectors in layer \(l\) and \(N_{l}\) is the number of feature maps.<br/> \(G^{l}_{ij}= \sum_{k}F^{l}_{ik}F^{l}_{jk}\).<br/> And so the Style loss is the Mean squared error between the gram matrices of Style image and the white noise image.<br/> Let \(\vec{a}\) be the style image and \(\vec{x}\) be the white noise image. Let \(A^{l}\) and \(X^{l}\) be the style representations of of style image and white noise image in layer \(l\). So, Total style loss of a layer \(l\) is \(E_{l}\).<br/> \(E_{l} = \frac{\sum_{i,j}(X^{l}_{ij}-A^{l}_{ij})^{2}}{4N^{2}_{l}M^{2}_{l}}\)<br/> So, the total style is<br/> \(L_{style}(\vec{a},\vec{x}) = \sum^{L}_{l=0}w_{l}E_{l}\)<br/> where \(w_{l}\) are the weighting factor of each layer.</p> <h3 id="hyperparameter-tuning">Hyperparameter tuning</h3> <p>To calculate the style and content loss, standard error back-propagation is done. To calculate \(L_{total}\), \(L_{content}\) is weighted by \(\alpha\) and \(L_{style}\) is weighted by \(\beta\).<br/> The ratio of \(\frac{\alpha}{\beta}\) is generally kept \(10^{-3}\) or \(10^{-4}\), this prevents the style from dominating and therefore preventing the loss of content.</p> <h1 id="neural-style-transfer-on-audio-signals"><ins>Neural Style Transfer on Audio Signals</ins></h1> <p>The base idea for Neural Style algorithm for audio signals is same as for images, the extracted style of the style audio is to be applied to the generated audio. Here, the content audio is directly used for generation instead of noise audio as this prevents calculation of content loss and eliminates the noise from the generated audio.</p> <h3 id="model-selection">Model Selection</h3> <p>For Audio signals 1 Dimensional Convolutions are used as they have different spatial features than images. So, models having 1-D CNN layers is used.<br/> It is observed that shallow models perform better than deep models and so a shallow model having only one layer but having large number of filters is used. The models are not pre-trained and have random weights as it is observed that it does not make a difference as we only need the encoding.</p> <h3 id="pre-processing">Pre-processing</h3> <p>An audio signal has to be converted to frequency domain from time domain because the frequencies have the spatial features of audio signals. The raw audio is converted to spectrogram via Short Time Fourier Transform(STFT). Spectrogram is a 2D Representation of a 1D signal, Spectrogram has \(C\) channels and \(S\) samples for every channel. So, a spectrogram can be considered as an \(1xS\) image with \(C\) channels.</p> <p><img src="https://ai2-s2-public.s3.amazonaws.com/figures/2017-08-08/7c592e7e00422dc7a76ead5932e34eafb5bef704/2-Figure2-1.png" alt="alt text"/></p> <h3 id="content-loss-1">Content Loss</h3> <p>Here, as the content audio is used for generation of the new audio i.e. the generated audio, content loss is not taken into consideration. However, it can be taken into consideration.<br/> So, here total loss is just the style loss</p> <h3 id="style-loss-1">Style Loss</h3> <p>For style extraction, gram matrices are used same as in images. Gram Matrix \(G \epsilon R^{ NxN }\), where \(G_{ij}\) is the inner product between the feature maps \(i\) and \(j\) represented by vectors and \(N\) is the number feature maps. The difference here is that the feature maps here are 1- Dimensional whereas in images they are 2D. Also, as we are using a model with only one layer, there is no notation of \(l\). Let \(F_{ij}\) be the spectrogram i.e. the encoding of the audio of \(i^{th}\) filter at \(j^{th}\) position.<br/> \(G_{ij}= \sum_{k}F_{ik}F_{jk}\).<br/> Style loss is the Mean squared error between the gram matrices of Style audio and the generated audio i.e. content audio.<br/> Let \(\vec{a}\) be the style audio and \(\vec{x}\) be the generated audio. Let \(A\) and \(X\) be the style representations of of style audio and generated audio with \(N\) number of channels(or number of filters) and \(M\) number of samples. So, Total style loss is \(L(\vec{a},\vec{x})_{style}\).<br/> \(L(\vec{a},\vec{x})_{style} = \frac{\sum_{i,j}(X_{ij}-A_{ij})^{2}}{4N^{2}M^{2}}\).<br/> Here, only one layer is present so thereâ€™s no significance of weighting of layer.</p> <h3 id="post-processing">Post-processing</h3> <p>After generation of audio phase reconstruction is done so as to convert the audio back to time domain from frequency domain. Griffin-Lim algorithm is used for reconstruction. Also, instead of using white noise to generate the final audio, the content audio is used which also prevents calculations as content loss is no longer needed, only style loss is used which is similar to images.</p> <h3 id="hyperparameter-tuning-1">Hyperparameter tuning</h3> <p>To calculate the style loss, standard error back-propagation is done.</p> <h1 id="future-work"><ins>Future Work</ins></h1> <p>With the coming of new generative models like Generative Adversarial Networks the neural style transfer algorithm can be modified and can be used for better results.</p> <h1 id="technology-overview"><ins>Technology Overview</ins></h1> <p>Python 2.7 is used for implementation and the model is implemented using Deep Learning library PyTorch. Librosa is used for audio analysis. The model is executed on IntelÂ® AI DevCloud which is 3x to 4x faster than the workstation being used, IntelÂ® AI DevCloud runs the models and processes on high-performance and efficient IntelÂ® XeonÂ® processors.</p> <h1 id="references"><ins>References</ins></h1> <h3 id="papers-">Papers :</h3> <ol> <li>Gatys, Leon A., Alexander S. Ecker, and Matthias Bethge. â€œImage style transfer using convolutional neural networks.â€ Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016.</li> <li>Grinstein, Eric, et al. â€œAudio style transfer.â€ arXiv preprint arXiv:1710.11385 (2017).</li> </ol> <h3 id="blogs-">Blogs :</h3> <ol> <li><a href="https://dmitryulyanov.github.io/audio-texture-synthesis-and-style-transfer/">Audio texture synthesis and style transfer by Dmitry Ulyanov and Vadim Lebedev</a></li> </ol> <h3 id="code-implementations-">Code Implementations :</h3> <ol> <li><a href="http://pytorch.org/tutorials/advanced/neural_style_tutorial.html#sphx-glr-advanced-neural-style-tutorial-py">Advanced Pytorch Tutorial for Neural Style Transfer</a></li> </ol> <h3 id="technical-components-">Technical Components :</h3> <ol> <li><a href="https://librosa.github.io/librosa/">Librosa</a></li> <li><a href="https://pytorch.org/">Pytorch</a></li> <li><a href="https://software.intel.com/en-us/ai-academy/devcloud">Intel AI DevCloud</a></li> </ol> <h3 id="project-resources-">Project Resources :</h3> <ol> <li><a href="https://devmesh.intel.com/projects/neural-style-transfer-on-audio-signals">Intel DevMesh Project</a></li> <li><a href="https://github.com/alishdipani/Neural-Style-Transfer-Audio">Github Repository</a></li> </ol>]]></content><author><name></name></author><category term="style-transfer,"/><category term="audio-processing"/><summary type="html"><![CDATA[Summary: Generation of new music using Neural Style Transfer Algorithm.]]></summary></entry></feed>