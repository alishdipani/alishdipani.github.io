<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> The Scatter plot example | Alish Dipani </title> <meta name="author" content="Alish Dipani"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="neuro-ai, computational-cognitive-neuroscience, vision-science"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://alishdipani.github.io/gsoc2019/2019/06/10/The-Scatter-plot-example/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Alish</span> Dipani </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Home </a> </li> <li class="nav-item "> <a class="nav-link" href="/journals/">Journals </a> </li> <li class="nav-item "> <a class="nav-link" href="/conferences/">Conferences </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/awards/">Awards </a> </li> <li class="nav-item "> <a class="nav-link" href="/service/">Service </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">More </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/invited-talks/">Invited Talks</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/experience/">Experience</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/open-source/">Open-source</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">The Scatter plot example</h1> <p class="post-meta"> Created in June 10, 2019 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2019   ·   <i class="fa-solid fa-hashtag fa-sm"></i> gsoc2019,   <i class="fa-solid fa-hashtag fa-sm"></i> rubyplot </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Summary: Explaining the scatter plot example.</p> <p><strong>Table of Contents</strong></p> <ul id="markdown-toc"> <li><a href="#introduction" id="markdown-toc-introduction">Introduction</a></li> <li><a href="#the-example-code" id="markdown-toc-the-example-code">The Example code</a></li> <li><a href="#an-overview" id="markdown-toc-an-overview">An overview</a></li> <li> <a href="#code-explanation" id="markdown-toc-code-explanation">Code Explanation</a> <ul> <li><a href="#figure" id="markdown-toc-figure">Figure</a></li> <li> <a href="#adding-a-subplot" id="markdown-toc-adding-a-subplot">Adding a subplot</a> <ul> <li> <a href="#axes" id="markdown-toc-axes">Axes</a> <ul> <li><a href="#x-axis-and-y-axis" id="markdown-toc-x-axis-and-y-axis">X Axis and Y axis</a></li> </ul> </li> </ul> </li> <li> <a href="#the-plot" id="markdown-toc-the-plot">The Plot</a> <ul> <li> <a href="#scatter-plot" id="markdown-toc-scatter-plot">Scatter Plot</a> <ul> <li><a href="#the-block-properties-of-the-scatter-plot" id="markdown-toc-the-block-properties-of-the-scatter-plot">The Block (properties of the scatter plot)</a></li> </ul> </li> </ul> </li> <li><a href="#axes-properties-properties-of-the-subplot" id="markdown-toc-axes-properties-properties-of-the-subplot">Axes properties (properties of the subplot)</a></li> <li> <a href="#writing-figure" id="markdown-toc-writing-figure">Writing Figure</a> <ul> <li><a href="#initializing-the-backend" id="markdown-toc-initializing-the-backend">Initializing the backend</a></li> <li><a href="#setting-up-the-background-gradient-creating-the-figure" id="markdown-toc-setting-up-the-background-gradient-creating-the-figure">Setting up the background gradient (creating the Figure)</a></li> <li><a href="#setting-up-the-output-device" id="markdown-toc-setting-up-the-output-device">Setting up the Output device</a></li> <li><a href="#processing-the-data-in-subplots" id="markdown-toc-processing-the-data-in-subplots">Processing the data in subplots</a></li> <li> <a href="#drawing-the-subplots" id="markdown-toc-drawing-the-subplots">Drawing the Subplots</a> <ul> <li><a href="#legend-box" id="markdown-toc-legend-box">Legend Box</a></li> </ul> </li> <li><a href="#x-and-y-ticks" id="markdown-toc-x-and-y-ticks">X and Y ticks</a></li> <li><a href="#x-axis-and-y-axis-1" id="markdown-toc-x-axis-and-y-axis-1">X axis and Y axis</a></li> <li><a href="#drawing-plots" id="markdown-toc-drawing-plots">Drawing plots</a></li> <li><a href="#writing-figure-backend" id="markdown-toc-writing-figure-backend">Writing Figure (Backend)</a></li> </ul> </li> <li><a href="#finishing-up" id="markdown-toc-finishing-up">Finishing up</a></li> </ul> </li> </ul> <h1 id="introduction">Introduction</h1> <p>In the project introduction blog <a href="https://alishdipani.github.io/gsoc2019/2019/06/09/GSoC-2019-project-introduction/">[Link]</a> a scatter plot example was given, I will be explaining the technical details for that example which involves explaining the code for the library using <strong>Magick backend</strong>.</p> <p><strong>P.S. - This blog is targeted towards new developers who want to get familiar with the codebase of the library or anyone who is extremely interested in technical code details as this blog is very technical and requires some familiarity with Rubyplot and rmagick.</strong><br> P.S. - The version of the library used for this example is of date 9 June.</p> <h1 id="the-example-code">The Example code</h1> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'Rubyplot'</span>
<span class="vi">@xdata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1"># Defining X data</span>
<span class="vi">@ydata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">65</span><span class="p">]</span> <span class="c1"># Defining Y data</span>
<span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># Creating the canvas</span>
<span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span> <span class="c1"># Adding a subplot (0,0 as only one subplot is to be plotted)</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">scatter!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="c1"># Setting scatter as the type of subplot</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
<span class="k">end</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Nice plot"</span> <span class="c1"># defining title of the plot</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_title</span> <span class="o">=</span> <span class="s2">"X data"</span> <span class="c1"># defining title of X axis</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_title</span> <span class="o">=</span> <span class="s2">"Y data"</span> <span class="c1"># defining title of Y axis</span>
<span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"scatterplot.png"</span><span class="p">)</span> <span class="c1"># Drawing the figure and saving it</span>
</code></pre></div></div> <p>The output using Magick backend is:<br> <img src="https://raw.githubusercontent.com/alishdipani/alishdipani.github.io/master/_posts/Resources/GSoC_2019_project_introduction/scatter_Magick.png" width="600"></p> <h1 id="an-overview">An overview</h1> <p>An overview of how the code works is that it first creates the canvas(figure) on which everything will be drawn, then the space for subplots is created in this figure and then the subplots are added. When a subplot is added, the type of the subplot (i.e. the plots in this particular subplot), the properties of the subplot, the data for the plots in this subplot, the title for the X axis, Y axis and the subplot itself etc. are defined. After setting the properties of all the subplots, the write function is called to actually draw and save the figure. During drawing everything is drawn including the Legendbox of the subplots.</p> <p>So, creating any figure in Rubyplot can be broken down into these steps:</p> <ol> <li>Create the Figure with desired properties.</li> <li>Define the number of subplots desired and thus the space for these subplots is created.</li> <li>Create the subplots one by one and set the desired properties of all the subplots.</li> <li>Call the <code class="language-plaintext highlighter-rouge">write</code> function to actually draw the Figure and thus the desired figure is created, drawn and saved.</li> </ol> <h1 id="code-explanation">Code Explanation</h1> <p>So to go through the code let’s start with the first 3 lines</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'Rubyplot'</span>
<span class="vi">@xdata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="c1"># Defining X data</span>
<span class="vi">@ydata</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">65</span><span class="p">]</span> <span class="c1"># Defining Y data</span>
</code></pre></div></div> <p>First Rubyplot is included which is similar to import in Python, this allows us to use Rubyplot. Next, we define 2 arrays <em>xdata</em> and <em>ydata</em> which store the X and Y coordinates to be plotted. So, the points to be plotted are (1,11), (2,2), (3,33), (4,4) and (5,65).</p> <h2 id="figure">Figure</h2> <p>After this, we create a new Figure object which will act as the canvas on which image will be drawn.</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Figure</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># Creating the canvas</span>
</code></pre></div></div> <p>Creating a figure object calls the constructor of the figure class.</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="ss">height: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">width: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">figsize_unit: :cm</span><span class="p">)</span>
    <span class="k">super</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="vi">@title</span> <span class="o">=</span> <span class="s1">''</span>
    <span class="vi">@nrows</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="vi">@ncols</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="vi">@width</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">||</span> <span class="no">DEFAULT_CANVAS_DIM</span><span class="p">).</span><span class="nf">to_f</span>
    <span class="vi">@height</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">||</span> <span class="no">DEFAULT_CANVAS_DIM</span><span class="p">).</span><span class="nf">to_f</span>
    <span class="vi">@top_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@bottom_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@left_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@right_spacing</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@subplots</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="vi">@figsize_unit</span> <span class="o">=</span> <span class="n">figsize_unit</span>
    <span class="n">set_rubyplot_artist_coords!</span>
    <span class="n">setup_default_theme</span>
    <span class="n">add_subplots!</span> <span class="vi">@nrows</span><span class="p">,</span> <span class="vi">@ncols</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here, <em>height</em> and <em>width</em> represent the height and width of the canvas to be made respectively. <em>figsize_unit</em> is for saving the unit for measurement which are pixel, centimeter or inch (default is cm).<br> Now, the Figure class inherits the Base class which initializes the origin for the figure in Rubyplot Coordinates which is set to 0,0.<br> After this default values are given to the required variables which include <em>width</em> and <em>height</em> set at 40 cm, spacing variables are for the margin for the figure (in pixels), <em>nrows</em> and <em>ncols</em> are the number of rows and columns in which each (row, column) represents a subplot, <em>subplots</em> variable is a 2-D array for storing subplots(which are axes objects), <em>title</em> is the title of the figure. Now, the function <strong>set_rubyplot_artist_coords!</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_rubyplot_artist_coords!</span>
  <span class="vi">@max_x</span> <span class="o">=</span> <span class="mf">100.0</span>
  <span class="vi">@max_y</span> <span class="o">=</span> <span class="mf">100.0</span>
  <span class="vi">@min_x</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="vi">@min_y</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="k">if</span> <span class="vi">@height</span> <span class="o">&gt;</span> <span class="vi">@width</span>
    <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="vi">@height</span> <span class="o">/</span> <span class="vi">@width</span>
    <span class="vi">@max_y</span> <span class="o">=</span> <span class="vi">@max_y</span> <span class="o">*</span> <span class="n">aspect_ratio</span>
  <span class="k">elsif</span> <span class="vi">@height</span> <span class="o">&lt;</span> <span class="vi">@width</span>
    <span class="n">aspect_ratio</span> <span class="o">=</span> <span class="vi">@width</span> <span class="o">/</span> <span class="vi">@height</span>
    <span class="vi">@max_x</span> <span class="o">=</span> <span class="vi">@max_x</span> <span class="o">*</span> <span class="n">aspect_ratio</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This sets the maximum and minimum coordinates for Rubyplot in Rubyplot coordinates and so the figure has an X and Y range as [0, max] for both X and Y coordinates in Rubyplot coordinates. Then this function defines the <em>aspect_ratio</em> and then changes the maximum value and the range for X or Y depending on the canvas height and width.</p> <p>After this, the function <strong>setup_default_theme</strong> is called which initializes some useful variables for the colour of the figure:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">setup_default_theme</span>
  <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">marker_color: :white</span><span class="p">,</span>
    <span class="ss">font_color: :black</span><span class="p">,</span>
    <span class="ss">background_image: </span><span class="kp">nil</span>
  <span class="p">}</span>
  <span class="vi">@theme_options</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">.</span><span class="nf">merge</span> <span class="no">Themes</span><span class="o">::</span><span class="no">CLASSIC_WHITE</span>
  <span class="vi">@marker_color</span> <span class="o">=</span> <span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:marker_color</span><span class="p">]</span>
  <span class="vi">@font_color</span> <span class="o">=</span> <span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:font_color</span><span class="p">]</span> <span class="o">||</span> <span class="vi">@marker_color</span>
<span class="k">end</span>
</code></pre></div></div> <p>First a <em>defaults</em> hash is defined which stores the default values of <em>marker_color</em> as the symbol <em>:white</em> which represents white colour, <em>font_color</em> as <em>:black</em> and <em>background_image</em> colour as nil. Then the empty <em>theme_options</em> hash is merged with a hash present in Themes module named <em>CLASSIC_WHITE</em>:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Plain White background with no gradient.</span>
<span class="no">CLASSIC_WHITE</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">marker_color: </span><span class="s1">'black'</span><span class="p">,</span>
  <span class="ss">font_color: </span><span class="s1">'black'</span><span class="p">,</span>
  <span class="ss">background_colors: </span><span class="sx">%I[white white]</span><span class="p">,</span>
  <span class="ss">label_colors: </span><span class="sx">%I[strong_blue vivid_orange dark_lime_green strong_red slightly_desaturated_violet dark_grey strong_yellow strong_cyan yellow maroon grey]</span>
<span class="p">}.</span><span class="nf">freeze</span>
</code></pre></div></div> <p>This hash which is now equal to <em>theme_options</em> has default values and represents a White background with no gradient.<br> After merging the values of <em>marker_color</em> and <em>theme_color</em> are set according to the <em>theme_options</em> hash defaults.</p> <p>Now the function <strong>add_subplots!</strong> is called which creates and initializes the <em>subplots</em> array:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_subplots!</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">)</span>
  <span class="vi">@nrows</span> <span class="o">=</span> <span class="n">nrows</span>
  <span class="vi">@ncols</span> <span class="o">=</span> <span class="n">ncols</span>
  <span class="vi">@subplots</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@nrows</span><span class="p">)</span> <span class="p">{</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@ncols</span><span class="p">)</span> <span class="p">{</span> <span class="kp">nil</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div> <p>The <em>subplots</em> array is of dimension <em>nrows</em> x <em>ncols</em>.</p> <h2 id="adding-a-subplot">Adding a subplot</h2> <p>After creating the figure, we move to adding subplots. To add a subplot the function <strong>add_subplot!</strong> is called</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">axes</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">add_subplot!</span> <span class="mi">0</span><span class="p">,</span><span class="mi">0</span>
</code></pre></div></div> <p>But first, we need to call the function <strong>add_subplots!</strong> to create the space for subplots i.e. initialize the <em>subplots</em> array and define the number of subplots. In this example, 0,0 specifies that only 1 subplot is to be created and we have already created the space for it(during initialization of the Figure) and so we don’t need to do it again.<br> Now, the function <strong>add_subplot!</strong> is called for our figure object:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_subplot!</span><span class="p">(</span><span class="n">nrow</span><span class="p">,</span> <span class="n">ncol</span><span class="p">)</span>
  <span class="n">plottable_width</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@max_x</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@left_spacing</span> <span class="o">+</span> <span class="vi">@right_spacing</span><span class="p">)).</span><span class="nf">to_f</span>
  <span class="n">plottable_length</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@max_y</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@top_spacing</span> <span class="o">+</span> <span class="vi">@bottom_spacing</span><span class="p">)).</span><span class="nf">to_f</span>
  <span class="vi">@subplots</span><span class="p">[</span><span class="n">nrow</span><span class="p">][</span><span class="n">ncol</span><span class="p">]</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Axes</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@left_spacing</span> <span class="o">+</span> <span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@ncols</span><span class="p">)</span> <span class="o">*</span> <span class="n">ncol</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@bottom_spacing</span> <span class="o">+</span> <span class="p">(</span><span class="n">plottable_length</span> <span class="o">/</span> <span class="vi">@nrows</span><span class="p">)</span> <span class="o">*</span> <span class="n">nrow</span><span class="p">,</span>
    <span class="ss">width: </span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@ncols</span><span class="p">,</span>
    <span class="ss">height: </span><span class="n">plottable_length</span> <span class="o">/</span> <span class="vi">@nrows</span>
  <span class="p">)</span>
  <span class="vi">@subplots</span><span class="p">[</span><span class="n">nrow</span><span class="p">][</span><span class="n">ncol</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function takes input the row and coloumn for the subplot which is 1,1 in our case but is stored as 0,0 in the <em>subplots</em> array. First, <em>plottable_width</em> and <em>plottable_length</em> are calculated in Rubyplot coordinate units which define the total space measurements in which plotting is allowed i.e. incorporating the spacing for the figure. Then a new Axes object is made and is stored in the <em>subplots</em> array at the index 0,0. The function then returns the <em>subplots</em> array at index 0,0 which is stored in <em>axes</em> variable.</p> <h3 id="axes">Axes</h3> <p>Now the <em>axes</em> variable contains an initialized Axes object which is also stored in <em>subplots</em> array at index 0,0. The Axes initialization is as follows:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">figure</span><span class="p">,</span> <span class="n">abs_x</span><span class="p">:,</span> <span class="n">abs_y</span><span class="p">:,</span> <span class="n">width</span><span class="p">:,</span> <span class="n">height</span><span class="p">:)</span>
  <span class="vi">@figure</span> <span class="o">=</span> <span class="n">figure</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
  <span class="vi">@width</span> <span class="o">=</span> <span class="n">width</span>
  <span class="vi">@height</span> <span class="o">=</span> <span class="n">height</span>

  <span class="vi">@x_title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@y_title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@top_margin</span> <span class="o">=</span> <span class="mf">5.0</span>
  <span class="vi">@left_margin</span> <span class="o">=</span> <span class="mf">10.0</span>
  <span class="vi">@bottom_margin</span> <span class="o">=</span> <span class="mf">10.0</span>
  <span class="vi">@right_margin</span> <span class="o">=</span> <span class="mf">5.0</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@title_shift</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@title_margin</span> <span class="o">=</span> <span class="no">TITLE_MARGIN</span>
  <span class="vi">@text_font</span> <span class="o">=</span> <span class="ss">:default</span>
  <span class="vi">@grid</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="vi">@bounding_box</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="vi">@plots</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@raw_rows</span> <span class="o">=</span> <span class="n">width</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span><span class="o">/</span><span class="n">width</span><span class="p">)</span>
  <span class="vi">@theme</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Themes</span><span class="o">::</span><span class="no">CLASSIC_WHITE</span>
  <span class="vi">@font</span> <span class="o">=</span> <span class="ss">:times_roman</span>
  <span class="vi">@font_color</span> <span class="o">=</span> <span class="ss">:black</span>
  <span class="vi">@font_size</span> <span class="o">=</span> <span class="mf">15.0</span>
  <span class="vi">@legend_font_size</span> <span class="o">=</span> <span class="mf">20.0</span>
  <span class="vi">@legend_margin</span> <span class="o">=</span> <span class="no">LEGEND_MARGIN</span>
  <span class="vi">@title_font_size</span> <span class="o">=</span> <span class="mf">25.0</span>
  <span class="vi">@plot_colors</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@legends</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@lines</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@texts</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@x_axis</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">XAxis</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="vi">@y_axis</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">YAxis</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="vi">@legend_box_position</span> <span class="o">=</span> <span class="ss">:top</span>
<span class="k">end</span>
</code></pre></div></div> <p>The inputs are the figure to which this axes belongs which was given by self, axs_x and abs_y are the X and Y coordinate of this axes’s lower left corner in Rubyplot coordinates and the <em>width</em> and <em>height</em> are the allowed space for this subplot i.e. the area in which this subplot is to be drawn.<br> Other important variables initialized margin variables which define the margin for this subplot(axes object), <em>plots</em> array which stores the plots to be drawn in this subplot, <em>xaxis</em> and <em>yaxis</em> which are an object of <em>XAxis</em> and <em>YAxis</em> respectively.<br> So, after initializing this axes object is stored in <em>axes</em> variable and <em>subplots</em> array at index 0,0.</p> <h4 id="x-axis-and-y-axis">X Axis and Y axis</h4> <p>We have initialized the variables <em>x_axis</em> and <em>y_axis</em> with new XAxis and YAxis objects, so when these objects are created, their constructor is called i.e. initialize function:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X Axis constructor</span>
<span class="k">def</span> <span class="nf">initialize</span> <span class="n">axes</span>
  <span class="k">super</span>
<span class="k">end</span>

<span class="c1"># Y axis constructor</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">super</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, both these classes inherit the Base of Axis and in the constructor of both of these classes, the constructor of Base is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span> <span class="n">axes</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">''</span>
  <span class="vi">@min_val</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@max_val</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@major_ticks_count</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="vi">@minor_ticks_count</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="vi">@texts</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@lines</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@major_ticks</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@minor_ticks</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@title_font_size</span> <span class="o">=</span> <span class="mf">25.0</span>
<span class="k">end</span>
</code></pre></div></div> <p>This constructor sets various useful properties of X and Y axes to their default values. It takes the axes object as an input to store it into <em>axes</em> variable to store the axes object to which it belongs, next the <em>title</em> is set to empty and the <em>max_val</em> and the <em>min_val</em> are stored to nil which store the maximum and minimum value of the X and the Y axes, next the number of major and minor ticks (between two major ticks) are stored, then two arrays are initialized <em>texts</em> and <em>lines</em> (not actually used) to store the texts and lines (tick lines not actual axis lines) for the X and Y axes, then the variables <em>major_ticks</em> and <em>minor_ticks</em> are set to nil which are used as arrays to store XTick and YTick objects corresponding to major(and minor) ticks of X-axis and major(and minor) ticks of Y-axis respectively. Finally, the font size of the title is set to 25 points.</p> <h2 id="the-plot">The Plot</h2> <p>Now, we have defined the subplot i.e. the axes object in which we want to draw our plot. The next lines of code are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">axes</span><span class="p">.</span><span class="nf">scatter!</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="c1"># Setting scatter as the type of subplot</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
  <span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, the function <strong>scatter!</strong> is called for the axes object. The block associated with the <strong>scatter!</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
</code></pre></div></div> <p>The block is a block of lines having commands which in this example are used for specifying properties of the plot in the subplot. This block is given to the <strong>scatter!</strong> function as an input:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scatter!</span><span class="p">(</span><span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">add_plot!</span> <span class="ss">:Scatter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the private <strong>add_plot!</strong> function:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">add_plot!</span> <span class="n">klass</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">plot</span> <span class="o">=</span> <span class="no">Kernel</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="s2">"Rubyplot::Artist::Plot::</span><span class="si">#{</span><span class="n">klass</span><span class="si">}</span><span class="s2">"</span><span class="p">).</span><span class="nf">new</span> <span class="nb">self</span>
  <span class="k">yield</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="n">plot</span>
<span class="k">end</span>
</code></pre></div></div> <p>The <strong>add_plot!</strong> function takes input as the class name for the plot which is Scatter in this example and the block is passed, then using Kernel a new object of the input class is created and is stored in <em>plot</em> variable which in this example is Scatter plot and so a <em>Scatter</em> object is created and stored in <em>plot</em> variable.<br> Then yield executes the block if block is given i.e. block_given?==true. After executing the block i.e. creating the plot and setting up the characteristics of the blog, the <em>plot</em> is appended in <em>plots</em> array.</p> <h3 id="scatter-plot">Scatter Plot</h3> <p>Now, before executing to the block, a Scatter object is initialized:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">super</span>
  <span class="vi">@marker_size</span> <span class="o">=</span> <span class="mf">1.0</span>
  <span class="vi">@marker_type</span> <span class="o">=</span> <span class="ss">:circle</span>
  <span class="vi">@marker_border_color</span> <span class="o">=</span> <span class="ss">:black</span>
  <span class="c1"># set fill to nil for the benefit of hollow markers so that legend</span>
  <span class="c1"># color defaults to :black in case user does not specify.</span>
  <span class="vi">@marker_fill_color</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first calls the base class which is inherited by Scatter, the initialize function is called. After that, different properties of the plot are set to default values which are stored in variables like marker size (set to 1), marker type (set to circle) which can be of different types like, triangle, plus, star, etc. (around 35 types available), marker border colour (set to black) and marker fill colour (set to nil). Now, the initialize function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span> <span class="n">axes</span>
<span class="k">super</span><span class="p">(</span><span class="n">axes</span><span class="p">.</span><span class="nf">abs_x</span><span class="p">,</span> <span class="n">axes</span><span class="p">.</span><span class="nf">abs_y</span><span class="p">)</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">label: </span><span class="s1">''</span><span class="p">,</span>
    <span class="ss">color: :default</span>
  <span class="p">}</span>
  <span class="vi">@normalized_data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="ss">y_values: </span><span class="kp">nil</span><span class="p">,</span>
    <span class="ss">x_values: </span><span class="kp">nil</span>
  <span class="p">}</span>
  <span class="vi">@stroke_width</span> <span class="o">=</span> <span class="mf">4.0</span>
  <span class="vi">@stroke_opacity</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">end</span>
</code></pre></div></div> <p>This again calls the base class of artist which is inherited by this base class, the initialize function is called. After that, an <em>axes</em> variable is initialized to store the axes pointer, a <em>data</em> hash is initialized which stores different properties of the subplot like label and colour for the legend, a <em>normalized_data</em> hash is initialized to store normalised data (not used), stroke width and stroke opacity (i.e. border width and opacity) are initialized with values 4 and 0 respectively. The initialize function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
<span class="k">end</span>
</code></pre></div></div> <p>This initialized function sets the absolute values (i.e. in Rubyplot coordinates) of the origin of this axes object i.e. of this subplot (which is the upper left corner for Magick backend).</p> <h4 id="the-block-properties-of-the-scatter-plot">The Block (properties of the scatter plot)</h4> <p>Now, the scatter object has been initialized and the block will be executed which sets the data to be plotted and other properties of the scatter plot. The block is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">p</span><span class="p">.</span><span class="nf">data</span> <span class="vi">@x1</span><span class="p">,</span> <span class="vi">@y1</span> <span class="c1"># setting data to be plotted</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">label</span> <span class="o">=</span> <span class="s2">"data1"</span> <span class="c1"># defining label for the data</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_border_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining border colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_fill_color</span> <span class="o">=</span> <span class="ss">:blue</span> <span class="c1"># defining fill colour of the markers</span>
<span class="nb">p</span><span class="p">.</span><span class="nf">marker_type</span> <span class="o">=</span> <span class="ss">:circle</span> <span class="c1"># defining marker type</span>
</code></pre></div></div> <p>Here p is the scatter plot object. First, the data is set to the <em>x1</em> and the <em>y1</em> arrays defined earlier:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function in base of plots</span>
<span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)</span>
  <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_values</span>
  <span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_values</span>
<span class="k">end</span>
</code></pre></div></div> <p>This stores the <em>x_vales</em> and <em>y_values</em> in the <em>data</em> hash. Then the label of the scatter plot is set:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function in base of plots</span>
<span class="k">def</span> <span class="nf">label</span><span class="o">=</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
  <span class="vi">@data</span><span class="p">[</span><span class="ss">:label</span><span class="p">]</span> <span class="o">=</span> <span class="n">label</span>
<span class="k">end</span>
</code></pre></div></div> <p>This overwrites the value of <em>label</em> in <em>data</em> hash.<br> Next, <em>marker_border_color</em> is set which is a variable of scatter plot which describes the colour of the border of the markers. So, in this example the colour is set to blue i.e. the variable <em>marker_border_color</em> is set to the symbol <em>:blue</em>.<br> Next, <em>marker_fill_color</em> is set which is a variable of scatter plot which describes the colour to be filled in the markers. So, in this example the colour is set to blue i.e. the variable <em>marker_fill_color</em> is set to the symbol <em>:blue</em>.<br> Finally, the marker type is set to circle i.e. the variable <em>marker_type</em> is set to the symbol <em>:circle</em>.</p> <h2 id="axes-properties-properties-of-the-subplot">Axes properties (properties of the subplot)</h2> <p>Finally after setting the scatter plot properties, the properties of the subplot i.e. the axes object are set:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">axes</span><span class="p">.</span><span class="nf">title</span> <span class="o">=</span> <span class="s2">"Nice plot"</span> <span class="c1"># defining title of the plot</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">x_title</span> <span class="o">=</span> <span class="s2">"X data"</span> <span class="c1"># defining title of X axis</span>
<span class="n">axes</span><span class="p">.</span><span class="nf">y_title</span> <span class="o">=</span> <span class="s2">"Y data"</span> <span class="c1"># defining title of Y axis</span>
</code></pre></div></div> <p>Axes object has these variables <em>title</em>, <em>x_title</em>, <em>y_title</em> which store a string which defines the title of the subplot, title of X-axis and title of Y-axis respectively.</p> <h2 id="writing-figure">Writing Figure</h2> <p>Till now we have only defined the properties and the data of the figure and have not actually plotted anything. Also notice that till now we haven’t actually made of the use of backend and have only used the frontend, one aim of Rubyplot is having a backend-agnostic frontend i.e. frontend should not be dependent on the backend.<br> Now we finally call the write function of the figure which actually draws everything and stores the figure as an Image:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@figure</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s2">"scatterplot.png"</span><span class="p">)</span> <span class="c1"># Drawing the figure and saving it</span>
</code></pre></div></div> <p>Now, the write function of figure is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_height</span> <span class="o">=</span> <span class="vi">@height</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">canvas_width</span> <span class="o">=</span> <span class="vi">@width</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">figure</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"RUBYPLOT_BACKEND"</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"MAGICK"</span>
    <span class="n">set_background_gradient</span>
  <span class="k">end</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">init_output_device</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span> <span class="p">}</span>
  <span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">write</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">stop_output_device</span>
<span class="k">end</span>
</code></pre></div></div> <p>Now, we start using the backend (it is initialized) and setting its properties, first the variables <em>canvas_height</em> and <em>canvas_width</em> are sset as the height and width of the canvas (figure), then the <em>figure</em> variable points to the Figure object.<br> Now the function <strong>set_background_gradient</strong> is called which is exclusive to Magick backend and its purpose is to make the canvas i.e. an Magick::Image object (P.S. - In future, this function will be shifted to the backend so that both backends are consistent).</p> <h3 id="initializing-the-backend">Initializing the backend</h3> <p>When any function or variable of the backend is called for the first time, the backend is initialized and its constructor is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span>
  <span class="vi">@axes_map</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">end</span>
</code></pre></div></div> <p>In Magick backend, during initialization an <em>axes_map</em> hash is defined which will later be used to store properties for X and Y axis corresponding to this particular axes which are currently being used.</p> <h3 id="setting-up-the-background-gradient-creating-the-figure">Setting up the background gradient (creating the Figure)</h3> <p>Now, the <strong>set_background_gradient</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_background_gradient</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">set_base_image_gradient</span><span class="p">(</span>
    <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:background_colors</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span>
    <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:background_colors</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span>
    <span class="vi">@width</span><span class="p">,</span>
    <span class="vi">@height</span><span class="p">,</span>
    <span class="vi">@theme_options</span><span class="p">[</span><span class="ss">:background_direction</span><span class="p">]</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the <strong>set_base_image_gradient</strong> function in the backend which creates the <em>base_image</em> variable which stores the Magick::Image object which is the canvas on which everything will be drawn, the canvas backgroung can have any solid colour or a gradient of two colours. <br> The first inputs given are the background top and bottom colour for the background gradient of the figure (<em>theme_options</em> hash was set up while initializing the figure), then the width and height of the figure and finally the gradient direction is set which is nil currently and will get take on the default value later.</p> <p>Now, the <strong>set_base_image_gradient</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_base_image_gradient</span><span class="p">(</span><span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">direct</span><span class="o">=</span><span class="ss">:top_bottom</span><span class="p">)</span>
  <span class="vi">@base_image</span> <span class="o">=</span> <span class="n">render_gradient</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">direct</span>
<span class="k">end</span>
</code></pre></div></div> <p>So the inputs to this are as explained above and the direction of the gradient is set to the symbol <em>:top_bottom</em>. So, the variable <em>base_image</em> is created which stores the Magick::Image object which is the figure, the value of <em>base_image</em> is returned by the function which is <strong>render_gradient</strong> which takes the same inputs as <strong>set_base_image_gradient</strong>, this function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Render a gradient and return an Image.</span>
<span class="k">def</span> <span class="nf">render_gradient</span><span class="p">(</span><span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">direct</span><span class="p">)</span>
  <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">scale_figure</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
  <span class="n">gradient_fill</span> <span class="o">=</span> <span class="k">case</span> <span class="n">direct</span>
                  <span class="k">when</span> <span class="ss">:bottom_top</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">top_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:left_right</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:right_left</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">top_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:topleft_bottomright</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">)</span>
                  <span class="k">when</span> <span class="ss">:topright_bottomleft</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">,</span> <span class="n">top_color</span><span class="p">)</span>
                  <span class="k">else</span>
                    <span class="no">GradientFill</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">top_color</span><span class="p">,</span> <span class="n">bottom_color</span><span class="p">)</span>
                  <span class="k">end</span>
  <span class="no">Magick</span><span class="o">::</span><span class="no">Image</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">gradient_fill</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>Now first the <strong>scale_figure</strong> function is called which scales the figure according to the unit of dimensions of the figure (stored in <em>figsize_units</em>) to pixels as Magick backend uses pixels as its unit. After scaling the figure the gradient of the figure background is stored in <em>gradient_fill</em>, this is a GradientFill object from ImageMagick which takes the inputs x,y coordinates of starting and ending of the gradient and the starting and ending colours.<br> Now, a new Magick::Image object is created (with the properties set) and returned which gets stored in <em>base_image</em>.</p> <p>The <strong>scale_figure</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Function to convert figure size to pixels</span>
<span class="k">def</span> <span class="nf">scale_figure</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
  <span class="p">[</span><span class="n">width</span> <span class="o">*</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">],</span> <span class="n">height</span> <span class="o">*</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">]]</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, in this function the width and height are multiplied with constants stored in <em>PIXEL_MULTIPLIERS</em> hash, i.e. to convert from inch to pixels, the width and size are multiplied with a constant. The <em>PIXEL_MULTIPLIERS</em> hash is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Multiplier needed to convert given unit into pixels. (Magick default).</span>
<span class="no">PIXEL_MULTIPLIERS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="ss">inch: </span><span class="mi">96</span><span class="p">,</span>
  <span class="ss">cm: </span><span class="mf">39.7953</span><span class="p">,</span>
  <span class="ss">pixel: </span><span class="mi">1</span>
<span class="p">}.</span><span class="nf">freeze</span>
</code></pre></div></div> <h3 id="setting-up-the-output-device">Setting up the Output device</h3> <p>After setting up the background gradient, the <strong>init_output_device</strong> function is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">init_output_device</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span><span class="p">)</span>
</code></pre></div></div> <p>This function takes input as the name of the image to be written and saved and the device to which it is to be saved which by default is <em>:file</em> symbol which represents the current folder of Rubyplot (device attribute is not used currently). The <strong>init_output_device</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">init_output_device</span> <span class="n">file_name</span><span class="p">,</span> <span class="ss">device: :file</span>
  <span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span> <span class="o">=</span> <span class="n">scale_figure</span><span class="p">(</span><span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span><span class="p">)</span>
  <span class="vi">@draw</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="no">Magick</span><span class="o">::</span><span class="no">Draw</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="n">file_name</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first modifies the <em>canvas_width</em> and the <em>canvas_height</em> variables according to the unit of the figure (<strong>scale_figure</strong> function was explained earlier). Then three new variables are defined <em>draw</em>, <em>axes</em> and <em>text</em> which are Magick::Draw objects which are used to draw shapes, X/Y axes and text respectively. Finally the <em>file_name</em> variable stores the file name string.</p> <h3 id="processing-the-data-in-subplots">Processing the data in subplots</h3> <p>Now, First the data in subplots is processed:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div> <p>For each subplot (axes object) stored in <em>subplots</em> array the function <strong>process_data</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_data</span>
  <span class="n">assign_default_label_colors</span>
  <span class="n">consolidate_plots</span>
  <span class="vi">@plots</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:process_data</span><span class="p">)</span>
  <span class="n">set_axes_ranges</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first calls the function <strong>assign_default_label_colors</strong> which sets the default colours for the each of the plots in this subplot, the function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">assign_default_label_colors</span>
  <span class="vi">@plots</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">p</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
    <span class="k">if</span> <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">==</span> <span class="ss">:default</span>
      <span class="nb">p</span><span class="p">.</span><span class="nf">color</span> <span class="o">=</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">theme_options</span><span class="p">[</span><span class="ss">:label_colors</span><span class="p">][</span>
        <span class="n">i</span> <span class="o">%</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">theme_options</span><span class="p">[</span><span class="ss">:label_colors</span><span class="p">].</span><span class="nf">size</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>In this function, for each plot in <em>plots</em> array (in this example only 1 scatter plot) the default colours are set, the value returned by the <strong>color</strong> function is checked and if it is <em>:default</em> then the default colours are set, the <strong>color</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">color</span>
  <span class="vi">@marker_fill_color</span> <span class="o">||</span> <span class="vi">@marker_border_color</span> <span class="o">||</span> <span class="ss">:default</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function returns the first value which is not nil (will return <em>:default</em> if both variables are nil).<br> So, this returns :default which causes the <strong>assign_default_label_colors</strong> function to go into the if case, and a colour is set using the <strong>color</strong> function, the colour set is decided by the <em>theme_options</em> hash using the key <em>:label_colors</em> which has an array of colours and the colour at the index ` i % @figure.theme_options[:label_colors].size` and in this example i = 0 since there is only one plot and the <em>:label_colors</em> variable is set to default (so 0 index is chosen and the colour present at 0 index is strong_blue). The <strong>color</strong> function used for setting colours is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Set both marker_fill_color and marker_border_color to the same color.</span>
<span class="k">def</span> <span class="nf">color</span><span class="o">=</span> <span class="n">color</span>
  <span class="vi">@marker_fill_color</span> <span class="o">=</span> <span class="n">color</span>
  <span class="vi">@marker_border_color</span> <span class="o">=</span> <span class="n">color</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, <em>marker_fill_color</em> and <em>marker_border_color</em> are set to the colour which was chosen as default i.e. strong_blue in this example.</p> <p>Now, next the function <strong>consolidate_plots</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">consolidate_plots</span>
  <span class="n">bars</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">Bar</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">bars</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">Bar</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiBars</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">bar_plots: </span><span class="n">bars</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">stacked_bars</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">StackedBar</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">stacked_bars</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">StackedBar</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiStackedBar</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">stacked_bars: </span><span class="n">stacked_bars</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">candle_sticks</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">CandleStick</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">candle_sticks</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">CandleStick</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiCandleStick</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span>
      <span class="ss">candle_sticks: </span><span class="n">candle_sticks</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">box_plots</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">BoxPlot</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">box_plots</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@plots</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="nb">p</span><span class="o">|</span> <span class="nb">p</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">BoxPlot</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@plots</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Plot</span><span class="o">::</span><span class="no">MultiBoxPlot</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span>
      <span class="ss">box_plots: </span><span class="n">box_plots</span><span class="p">)</span>
  <span class="k">end</span>        
<span class="k">end</span>
</code></pre></div></div> <p>This function checks if multiple bar plots/stacked bar plots/candle stick plots/box plots are present and if there are multiple of these plots then a new multi bar plot/multi stacked bar plot/multi candle stick plot/multi box plot is created correspondingly. In this example no such plot is present and hence the function does not do anything.</p> <p>Next, for each plot present in this subplot i.e. in the <em>plots</em> array, the <strong>process_data</strong> function is called. In this example only one scatter plot is present and hence the <strong>process_data</strong> function of scatter plot is called (which is inherited from the base and is present in the base):</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_data</span>
  <span class="vi">@y_min</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">].</span><span class="nf">min</span>
  <span class="vi">@y_max</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">].</span><span class="nf">max</span>
  <span class="vi">@x_min</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">min</span>
  <span class="vi">@x_max</span> <span class="o">=</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">max</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function stores the maximum and minimum X and Y values in the corresponding variables.</p> <p>Finally, the <strong>set_axes_ranges</strong> function is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_axes_ranges</span>
  <span class="n">set_xrange</span>
  <span class="n">set_yrange</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the functions <strong>set_xrange</strong> and <strong>set_yrange</strong> which are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">set_xrange</span>
  <span class="k">if</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:x_min</span><span class="p">).</span><span class="nf">min</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">max_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:x_max</span><span class="p">).</span><span class="nf">max</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">set_yrange</span>
  <span class="k">if</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:y_min</span><span class="p">).</span><span class="nf">min</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">max_val</span> <span class="o">=</span> <span class="vi">@plots</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:y_max</span><span class="p">).</span><span class="nf">max</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Both of these functions first check if the corresponding maximum and minimum values are nil or not (which they are by default) in <em>x_axis</em> and <em>y_axis</em> which store the XAxis and YAxis objects respectively, and if they are nil (which they are in this example currently) then it calculates the minimum and maximum values across all the plots present in this subplot(i.e. in the <em>plots</em> array) and then sets the corresponding variables to the corresponding values.</p> <h3 id="drawing-the-subplots">Drawing the Subplots</h3> <p>Next each subplot in <em>subplots</em> array is drawn:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@subplots</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div> <p>The draw function of axes is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Write an image to a file by communicating with the backend.</span>
<span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">active_axes</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="n">configure_title</span>
  <span class="n">configure_legends</span>
  <span class="n">assign_x_ticks</span>
  <span class="n">assign_y_ticks</span>
  <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
  <span class="vi">@legend_box</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@plots</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>First the <em>active_axes</em> variable is set to the current axes object which is to be drawn, next the function <strong>configure_title</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Figure out the co-ordinates of the title text w.r.t Axes.</span>
<span class="k">def</span> <span class="nf">configure_title</span>
  <span class="vi">@texts</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@title</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="n">abs_x</span> <span class="o">+</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">abs_y: </span><span class="n">abs_y</span> <span class="o">+</span> <span class="n">height</span><span class="p">,</span>
    <span class="ss">font: </span><span class="vi">@font</span><span class="p">,</span> <span class="ss">color: </span><span class="vi">@font_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@title_font_size</span><span class="p">,</span> <span class="ss">internal_label: </span><span class="s1">'axes title.'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function sets the title of this subplot (in this example the title is set to ‘Nice plot’). So a new Text object is added to the <em>texts</em> array of the active axes, the inputs for initializing the Text object are first the text, then the owner of this text i.e. the active axes, then the x coordinate and y coordinate in Rubyplot coordinates, then the font, font colour, font size (in points) and an internal label. Currently, the position of title is kept static and is at the center of the width and at maximum height of the axes (adding these with the x and y origin values of the axes gives the Rubyplot coordinates of the text). The initialize function of Text is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">abs_x</span><span class="p">:,</span> <span class="n">abs_y</span><span class="p">:,</span><span class="ss">font: :times_roman</span><span class="p">,</span>
  <span class="ss">color: :black</span><span class="p">,</span> <span class="n">size</span><span class="p">:,</span> <span class="ss">internal_label: </span><span class="s1">''</span><span class="p">,</span> <span class="ss">rotation: </span><span class="kp">nil</span><span class="p">,</span>
  <span class="ss">weight: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">halign: :normal</span><span class="p">,</span> <span class="ss">valign: :normal</span><span class="p">,</span> <span class="ss">direction: :left_right</span><span class="p">)</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="n">text</span>
  <span class="vi">@owner</span> <span class="o">=</span> <span class="n">owner</span>
  <span class="vi">@font</span> <span class="o">=</span> <span class="n">font</span>
  <span class="vi">@color</span> <span class="o">=</span> <span class="n">color</span>
  <span class="vi">@size</span> <span class="o">=</span> <span class="n">size</span>
  <span class="vi">@internal_label</span> <span class="o">=</span> <span class="n">internal_label</span>
  <span class="vi">@rotation</span> <span class="o">=</span> <span class="n">rotation</span>
  <span class="k">if</span> <span class="no">HAlignment</span><span class="p">.</span><span class="nf">include?</span> <span class="n">halign</span>
    <span class="vi">@halign</span> <span class="o">=</span> <span class="n">halign</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="s2">"Invalid horizontal alignment </span><span class="si">#{</span><span class="n">halign</span><span class="si">}</span><span class="s2">."</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="no">VAlignment</span><span class="p">.</span><span class="nf">include?</span> <span class="n">valign</span>
    <span class="vi">@valign</span> <span class="o">=</span> <span class="n">valign</span>
  <span class="k">else</span>
    <span class="k">raise</span> <span class="s2">"Invalid vertical alignment </span><span class="si">#{</span><span class="n">valign</span><span class="si">}</span><span class="s2">."</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This sets all the required variables including the rotation for text if required and the alignment too.</p> <h4 id="legend-box">Legend Box</h4> <p>After configuring the label, the function <strong>configure_legends</strong> is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Figure out co-ordinates of the legends</span>
<span class="k">def</span> <span class="nf">configure_legends</span>
  <span class="vi">@legend_box</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">LegendBox</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span> <span class="ss">abs_x: </span><span class="n">legend_box_ix</span><span class="p">,</span> <span class="ss">abs_y: </span><span class="n">legend_box_iy</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates a new LegendBox object which defines the legend of the subplot, the inputs given are the owner of this legend box i.e. the subplot, then the absolute value (i.e. in Rubyplot coordinates) of x and y coordinates which correspond to the lower right corner of the legend box. The functions <strong>legend_box_ix</strong> and <strong>legend_box_ix</strong> are called to give the absolute X and Y coordinate for the lower right corner of the legend box. The functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X co-ordinate of the legend box depending on value of @legend_box_position.</span>
<span class="k">def</span> <span class="nf">legend_box_ix</span>
  <span class="k">case</span> <span class="vi">@legend_box_position</span>
  <span class="k">when</span> <span class="ss">:top</span>
    <span class="n">abs_x</span> <span class="o">+</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Y co-ordinate of the legend box depending on value of @legend_box_position.</span>
<span class="k">def</span> <span class="nf">legend_box_iy</span>
  <span class="k">case</span> <span class="vi">@legend_box_position</span>
  <span class="k">when</span> <span class="ss">:top</span>
    <span class="n">abs_y</span> <span class="o">+</span> <span class="n">height</span> <span class="o">-</span> <span class="n">top_margin</span> <span class="o">-</span> <span class="n">legend_margin</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>These functions set the X coordinate to center of width and Y coordinate to the maximum height of the axes excluding the corresponding margins.</p> <p>The initialize function of the LegendBox is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">abs_x</span><span class="p">:,</span> <span class="n">abs_y</span><span class="p">:)</span>
  <span class="k">super</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@border_color</span> <span class="o">=</span> <span class="ss">:black</span>
  <span class="vi">@legends</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">configure_dimensions</span>
  <span class="n">configure_legends</span>
  <span class="n">configure_legend_box</span>
<span class="k">end</span>
</code></pre></div></div> <p>This first calls the initialize of parent class i.e. base:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@abs_x</span> <span class="o">=</span> <span class="n">abs_x</span>
  <span class="vi">@abs_y</span> <span class="o">=</span> <span class="n">abs_y</span>
<span class="k">end</span>
</code></pre></div></div> <p>which just sets the lower right coordinates of the legend box, next <em>axes</em> is set to its owner i.e. the subplot and then <em>border_color</em> of the legend box i.e. the colour of the outer rectangle of the legend box i.e. the colour of the box. Then the array <em>legends</em> is created which stores the legend objects. Next, the function <strong>configure_dimensions</strong> is called which sets the dimensions for the legend box:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_dimensions</span>
  <span class="vi">@legends_height</span> <span class="o">=</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">plots</span><span class="p">.</span><span class="nf">size</span> <span class="o">*</span> <span class="n">per_legend_height</span>
  <span class="vi">@legends_width</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">width</span>
  <span class="vi">@height</span> <span class="o">=</span> <span class="vi">@legends_height</span> <span class="o">+</span> <span class="n">top_margin</span> <span class="o">+</span> <span class="n">bottom_margin</span>
  <span class="vi">@width</span> <span class="o">=</span> <span class="vi">@legends_width</span> <span class="o">+</span> <span class="n">left_margin</span> <span class="o">+</span> <span class="n">right_margin</span>
<span class="k">end</span>
</code></pre></div></div> <p>The functions called here are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">top_margin</span>
  <span class="no">TOP_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_height</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">bottom_margin</span>
  <span class="no">BOTTOM_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_height</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">left_margin</span>
  <span class="no">LEFT_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_width</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">right_margin</span>
  <span class="no">RIGHT_SPACING_RATIO</span> <span class="o">*</span> <span class="vi">@legends_width</span>
<span class="k">end</span>

<span class="c1"># Height of each legend in Rubyplot Artist Co-ordinates.</span>
<span class="k">def</span> <span class="nf">per_legend_height</span>
  <span class="mi">5</span>
<span class="k">end</span>
</code></pre></div></div> <p>So, in <strong>configure_dimensions</strong> first the total height of legends is set which is number of plots * height per legend (which is set to 5 Rubyplot coordinates), then the length of the legends is width of the subplot * 0.2, Then the total height and width for the legend box is calculated i.e. margins are incorporated (each margin ratio is set to 0.1).</p> <p>After fixing the legend box dimensions, the legends are created which are Legend objects using the <strong>configure_legends</strong> function, which is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legends</span>
  <span class="vi">@axes</span><span class="p">.</span><span class="nf">plots</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">plot</span><span class="p">,</span> <span class="n">count</span><span class="o">|</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">plot</span><span class="p">.</span><span class="nf">label</span> <span class="o">!=</span> <span class="s1">''</span>      
    <span class="vi">@legends</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Legend</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
      <span class="nb">self</span><span class="p">,</span>
      <span class="vi">@axes</span><span class="p">,</span>
      <span class="ss">text: </span><span class="n">plot</span><span class="p">.</span><span class="nf">label</span><span class="p">,</span>
      <span class="ss">color: </span><span class="n">plot</span><span class="p">.</span><span class="nf">color</span><span class="p">,</span>
      <span class="ss">abs_x: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="n">left_margin</span><span class="p">,</span>
      <span class="ss">abs_y: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="n">count</span> <span class="o">*</span> <span class="n">per_legend_height</span> <span class="o">+</span> <span class="n">bottom_margin</span><span class="p">,</span>
    <span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates a legend which is a Legend object having a square with the colour of the data and its label for every plot stored in the <em>plots</em> array. So for each plot a Legend object is made and added to the <em>legends</em> array, any plot with an empty label is skipped. The inputs given to create a new Legend object are first the owner of this legend i.e. the legend box, then the subplot to which it belongs i.e. the axes object, then the label of the plot, colour of the plot and finally the x,y coordinate of the lower left corner of the legend in Rubyplot coordinates. The initialize function of Legend is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">legend_box</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">text</span><span class="p">:,</span> <span class="n">color</span><span class="p">:,</span><span class="n">abs_x</span><span class="p">:,</span><span class="n">abs_y</span><span class="p">:)</span>
  <span class="k">super</span><span class="p">(</span><span class="n">abs_x</span><span class="p">,</span> <span class="n">abs_y</span><span class="p">)</span>
  <span class="vi">@legend_box</span> <span class="o">=</span> <span class="n">legend_box</span>
  <span class="vi">@axes</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="n">text</span>
  <span class="vi">@color</span> <span class="o">=</span> <span class="n">color</span>
  <span class="vi">@legend_box_size</span> <span class="o">=</span> <span class="vi">@legend_box</span><span class="p">.</span><span class="nf">per_legend_height</span> <span class="o">-</span>
                     <span class="p">(</span><span class="no">TOP_MARGIN</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span><span class="p">)</span> <span class="c1"># size of the color box of the legend.</span>
  <span class="vi">@font_size</span> <span class="o">=</span> <span class="mf">20.0</span>
  <span class="vi">@font</span> <span class="o">=</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">font</span>
  <span class="vi">@font_color</span> <span class="o">=</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">font_color</span>
  <span class="n">configure_legend_color_box</span>
  <span class="n">configure_legend_text</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here first the constructor(initialize function) of the parent class base is called which just sets the x,y coorindates of the lower left corner, then all the important variables are set according to the input and then the <strong>configure_legend_color_box</strong> is called which creates the square for the legend:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legend_color_box</span>
  <span class="vi">@legend_color_box</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Rectangle</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">x1: </span><span class="vi">@abs_x</span><span class="p">,</span>
    <span class="ss">y1: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span><span class="p">,</span>
    <span class="ss">x2: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="vi">@legend_box_size</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="vi">@legend_box_size</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">abs: </span><span class="kp">true</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function stores a Rectangle object in the variable <em>legend_color_box</em>. The inputs given to create a new Rectangle object are first the owner of the rectangle then the x,y coorindates of lower left and upper right corners, then the border colour and the colour to be filled and finally absolute flag representing whether the coordinates are in Rubyplot cooridnates(abs = True) or not(abs = False). The initialize function of Rectangle class is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span><span class="n">x1</span><span class="p">:,</span><span class="n">y1</span><span class="p">:,</span><span class="n">x2</span><span class="p">:,</span><span class="n">y2</span><span class="p">:,</span><span class="n">border_color</span><span class="p">:,</span><span class="ss">fill_color: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
  <span class="vi">@x1</span> <span class="o">=</span> <span class="n">x1</span>
  <span class="vi">@x2</span> <span class="o">=</span> <span class="n">x2</span>
  <span class="vi">@y1</span> <span class="o">=</span> <span class="n">y1</span>
  <span class="vi">@y2</span> <span class="o">=</span> <span class="n">y2</span>
  <span class="vi">@border_color</span> <span class="o">=</span> <span class="n">border_color</span>
  <span class="vi">@fill_color</span> <span class="o">=</span> <span class="n">fill_color</span>
  <span class="vi">@abs</span> <span class="o">=</span> <span class="n">abs</span>
<span class="k">end</span>
</code></pre></div></div> <p>This just sets all the variables according to the input.</p> <p>Now, the <strong>configure_legend_text</strong> is called which creates the text for the legend:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legend_text</span>
  <span class="vi">@text</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@text</span><span class="p">,</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="vi">@legend_box_size</span> <span class="o">+</span> <span class="no">BOX_AND_TEXT_SPACE</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="no">BOTTOM_MARGIN</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
    <span class="ss">font: </span><span class="vi">@font</span><span class="p">,</span>
    <span class="ss">color: </span><span class="vi">@font_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@font_size</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates a Text object and stores it in the <em>text</em> variable. The inputs are given to create the Text object (Text object was discussed earlier), here the <em>BOX_AND_TEXT_SPACE</em> represents the space between the box and the text which is set to 0.5 .</p> <p>So, after configuring the dimensions of the legend box and the legends, the legend box is configured by calling the <em>configure_legend_box</em> function:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">configure_legend_box</span>
  <span class="vi">@bounding_box</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Rectangle</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">x1: </span><span class="vi">@abs_x</span><span class="p">,</span>
    <span class="ss">y1: </span><span class="vi">@abs_y</span><span class="p">,</span>
    <span class="ss">x2: </span><span class="vi">@abs_x</span> <span class="o">+</span> <span class="vi">@width</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="vi">@abs_y</span> <span class="o">+</span> <span class="vi">@height</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@border_color</span><span class="p">,</span>
    <span class="ss">abs: </span><span class="kp">true</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function creates the bounding box which is the outer rectangle of the legend box. The <em>bounding_box</em> is a Rectangle object (which was discussed earlier).</p> <h3 id="x-and-y-ticks">X and Y ticks</h3> <p>Finally, the LegendBox object is created and we continue to the draw function of the axes i.e. the subplot.<br> Next the functions <strong>assign_x_ticks</strong> and <strong>assign_y_ticks</strong> are called which assign the ticks to the X and Y axes. The functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">assign_x_ticks</span>
  <span class="n">value_distance</span> <span class="o">=</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">spread</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks_count</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">unless</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span> <span class="c1"># create labels if not present</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span> <span class="o">=</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks_count</span><span class="p">.</span><span class="nf">times</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
      <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">value_distance</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">XTick</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">map!</span><span class="p">.</span><span class="nf">with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">tick_label</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
      <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">XTick</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
        <span class="nb">self</span><span class="p">,</span>
        <span class="ss">coord: </span><span class="n">i</span> <span class="o">*</span> <span class="n">value_distance</span> <span class="o">+</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">,</span>
        <span class="ss">label: </span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Utils</span><span class="p">.</span><span class="nf">format_label</span><span class="p">(</span><span class="n">tick_label</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">assign_y_ticks</span>
  <span class="n">value_distance</span> <span class="o">=</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">spread</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks_count</span><span class="p">.</span><span class="nf">to_f</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">unless</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">..</span><span class="n">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]).</span><span class="nf">step</span><span class="p">(</span><span class="n">value_distance</span><span class="p">).</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">all?</span> <span class="p">{</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span> <span class="n">t</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">YTick</span><span class="p">)</span> <span class="p">}</span>
    <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">major_ticks</span><span class="p">.</span><span class="nf">map!</span><span class="p">.</span><span class="nf">with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">tick_label</span><span class="p">,</span> <span class="n">i</span><span class="o">|</span>
      <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">YTick</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
        <span class="nb">self</span><span class="p">,</span>
        <span class="ss">coord: </span><span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">value_distance</span><span class="p">,</span>
        <span class="ss">label: </span><span class="no">Rubyplot</span><span class="o">::</span><span class="no">Utils</span><span class="p">.</span><span class="nf">format_label</span><span class="p">(</span><span class="n">tick_label</span><span class="p">)</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>These functions decide the coordinates for the ticks according to the number of ticks required and then these functions create an array to store the ticks which are <em>XTick</em> and <em>YTick</em> objects. The ticks are of two types (both for X and Y axes), minor tick and major tick which represent a smaller and a bigger tick relatively (the size of the major tick is twice the size of minor tick).<br> <strong>P.S. - Currently the ticks are not implemented for Magick backend and changes are required in the frontend of ticks as well and hence ticks will be discussed in detail in a later blog.</strong></p> <h3 id="x-axis-and-y-axis-1">X axis and Y axis</h3> <p>Now, returning to the draw function of the axes, we actually start to draw the plots (Notice, till now we haven’t actually drawn anything). So the next lines of code are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@x_axis</span><span class="p">.</span><span class="nf">draw</span>
<span class="vi">@y_axis</span><span class="p">.</span><span class="nf">draw</span>
</code></pre></div></div> <p>The <strong>draw</strong> function of XAxis and YAxis objects (which were stored in the variables <em>x_axis</em> and <em>y_axis</em> respectively) is called to draw the axes:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X Axis</span>
<span class="k">def</span> <span class="nf">draw</span>
  <span class="n">configure_title</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_x_axis</span><span class="p">(</span>
    <span class="ss">origin: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">origin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="ss">major_ticks: </span><span class="vi">@major_ticks</span><span class="p">,</span>
    <span class="ss">minor_ticks: </span><span class="vi">@minor_ticks</span><span class="p">,</span>
    <span class="ss">major_ticks_count: </span><span class="vi">@major_ticks_count</span>
  <span class="p">)</span>
  <span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Y Axis</span>
<span class="k">def</span> <span class="nf">draw</span>
  <span class="n">configure_title</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_y_axis</span><span class="p">(</span>
    <span class="ss">origin: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">origin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="ss">major_ticks: </span><span class="vi">@major_ticks</span><span class="p">,</span>
    <span class="ss">minor_ticks: </span><span class="vi">@minor_ticks</span><span class="p">,</span>
    <span class="ss">major_ticks_count: </span><span class="vi">@major_ticks_count</span>
  <span class="p">)</span>
  <span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>First both the X and Y axes call the function <strong>configure_title</strong> which sets the title of X axis and Y axis respectively:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># X Axis</span>
<span class="k">def</span> <span class="nf">configure_title</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">'X axis'</span> <span class="k">if</span> <span class="vi">@title</span> <span class="o">==</span> <span class="s1">''</span>
  <span class="vi">@texts</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@title</span><span class="p">,</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@title_font_size</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_y</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_x</span> <span class="o">+</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">width</span><span class="o">/</span><span class="mi">2</span>
  <span class="p">)</span>
<span class="k">end</span>

<span class="c1"># Y Axis</span>
<span class="k">def</span> <span class="nf">configure_title</span>
  <span class="vi">@title</span> <span class="o">=</span> <span class="s1">'Y axis'</span> <span class="k">if</span> <span class="vi">@title</span> <span class="o">==</span> <span class="s1">''</span>
  <span class="vi">@texts</span> <span class="o">&lt;&lt;</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Artist</span><span class="o">::</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span>
    <span class="vi">@title</span><span class="p">,</span>
    <span class="nb">self</span><span class="p">,</span>
    <span class="ss">rotation: </span><span class="o">-</span><span class="mf">90.0</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_x</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@axes</span><span class="p">.</span><span class="nf">abs_y</span> <span class="o">+</span> <span class="vi">@axes</span><span class="p">.</span><span class="nf">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@title_font_size</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first checks if the title is empty and if it is the title is set to ‘X axis’ and ‘Y axis’ for X axis and Y axis respectively, this is done to set the default titles. After modifying the <em>title</em> variable if needed, a new Text object (which was discussed earlier) for the title is added to the <em>texts</em> array for both X and Y axes.<br> One thing to note is that rotation is given to the Text object for the Y-axis as the text is to be printed vertically.</p> <p>After configuring the title, the backend functions <strong>draw_x_axis</strong> and <strong>draw_y_axis</strong> are called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_x_axis</span><span class="p">(</span><span class="n">minor_ticks</span><span class="p">:,</span> <span class="n">origin</span><span class="p">:,</span> <span class="n">major_ticks</span><span class="p">:,</span> <span class="n">major_ticks_count</span><span class="p">:)</span>
  <span class="k">if</span> <span class="vi">@axes_map</span><span class="p">[</span><span class="n">active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">nil?</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
      <span class="ss">axes: </span><span class="vi">@active_axes</span><span class="p">,</span>
      <span class="ss">x_origin: </span><span class="n">origin</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">merge!</span><span class="p">(</span><span class="ss">x_origin: </span><span class="n">origin</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">draw_y_axis</span><span class="p">(</span><span class="n">minor_ticks</span><span class="p">:,</span> <span class="n">origin</span><span class="p">:,</span> <span class="n">major_ticks</span><span class="p">:,</span> <span class="n">major_ticks_count</span><span class="p">:)</span>
  <span class="k">if</span> <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">nil?</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">]</span><span class="o">=</span><span class="p">{</span>
      <span class="ss">axes: </span><span class="vi">@active_axes</span><span class="p">,</span>
      <span class="ss">y_origin: </span><span class="n">origin</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="vi">@axes_map</span><span class="p">[</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">object_id</span><span class="p">].</span><span class="nf">merge!</span><span class="p">(</span><span class="ss">y_origin: </span><span class="n">origin</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>The inputs given to the functions are the array for minor ticks (having XTick or YTick objects), the origin, the array for major ticks (having XTick or YTick objects) and finally the number of major ticks to be drawn.<br> The functions first check if the <em>axes_map</em> hash (initialized in the initialize function of the magick wrapper i.e. the backend) is empty (i.e., if the key for the current axes object stored in <em>active_axes</em> is not present) and if it is then a new key, value pair is created otherwise the value is added. The value for a key i.e. a subplot (axes) object is an array which stores the axes to which this value belongs, the origin of X-axis and Y-axis.<br> Note that there is only one value array for both X-axis and Y-axis for axes object i.e. a subplot.<br> So, the origins are stored in a hash and after that, in the <strong>draw</strong> function for both the axes, this command is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
</code></pre></div></div> <p>This command calls the <strong>draw</strong> function for each of the Text objects present in <em>texts</em> array. The <strong>draw</strong> function of the Text object is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_text</span><span class="p">(</span>
    <span class="vi">@text</span><span class="p">,</span>
    <span class="ss">color: </span><span class="vi">@color</span><span class="p">,</span>
    <span class="ss">font: </span><span class="vi">@font</span><span class="p">,</span>
    <span class="ss">size: </span><span class="vi">@size</span><span class="p">,</span>
    <span class="ss">abs_x: </span><span class="vi">@abs_x</span><span class="p">,</span>
    <span class="ss">abs_y: </span><span class="vi">@abs_y</span><span class="p">,</span>
    <span class="ss">rotation: </span><span class="vi">@rotation</span><span class="p">,</span>
    <span class="ss">halign: </span><span class="vi">@halign</span><span class="p">,</span>
    <span class="ss">valign: </span><span class="vi">@valign</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function calls the <strong>draw_text</strong> of the backend and passes all the useful variables, the <strong>draw_text</strong> is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_text</span><span class="p">(</span><span class="n">text</span><span class="p">,</span><span class="ss">color: :default</span><span class="p">,</span><span class="ss">font: </span><span class="kp">nil</span><span class="p">,</span><span class="n">size</span><span class="p">:,</span>
        <span class="ss">font_weight: </span><span class="no">Magick</span><span class="o">::</span><span class="no">NormalWeight</span><span class="p">,</span> <span class="n">halign</span><span class="p">:,</span> <span class="n">valign</span><span class="p">:,</span>
        <span class="n">abs_x</span><span class="p">:,</span><span class="n">abs_y</span><span class="p">:,</span><span class="ss">rotation: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">stroke: </span><span class="s1">'transparent'</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">true</span><span class="p">)</span>
  <span class="k">unless</span> <span class="n">text</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="n">within_window</span><span class="p">(</span><span class="n">abs</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">abs_x</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">abs_y</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>

      <span class="vi">@text</span><span class="p">.</span><span class="nf">fill</span> <span class="o">=</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">color</span><span class="p">]</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">font</span> <span class="o">=</span> <span class="n">font</span><span class="p">.</span><span class="nf">to_s</span> <span class="k">if</span> <span class="n">font</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">pointsize</span> <span class="o">=</span> <span class="n">size</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">font_weight</span> <span class="o">=</span> <span class="n">font_weight</span>
      <span class="c1"># @text.gravity = GRAVITY_MEASURE[gravity] || Magick::ForgetGravity</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">stroke</span> <span class="n">stroke</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">stroke_antialias</span> <span class="kp">false</span>
      <span class="vi">@text</span><span class="p">.</span><span class="nf">text_antialias</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="n">modify_draw</span><span class="p">(</span><span class="vi">@text</span><span class="p">,</span> <span class="ss">x_shift: </span><span class="n">x</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="ss">y_shift: </span><span class="n">y</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="ss">rotation: </span><span class="n">rotation</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">draw</span><span class="o">|</span>
        <span class="n">draw</span><span class="p">.</span><span class="nf">text</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">text</span><span class="p">.</span><span class="nf">gsub</span><span class="p">(</span><span class="s1">'%'</span><span class="p">,</span> <span class="s1">'%%'</span><span class="p">))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Apart from the self-explanatory, the other variables are <em>font_weight</em> which represents Magick’s weight properties(currently not used), <em>halign</em> and <em>valign</em> whcih represent horizontal and vertical alignments respectively, rotation if the text is to be rotated and the stroke which defines the pattern for the text (does not make a difference currently) and the absolute flag as abs.<br> This function first checks whether the text argument is given or not and only proceeds if it is given. Next, the <strong>within_window</strong> function is called which sets up the area (the window) in which the drawing is to be done. This function takes a block as input which is just a collection of lines of code to be executed. The function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_window</span><span class="p">(</span><span class="n">abs</span><span class="o">=</span><span class="kp">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">abs</span>
    <span class="c1"># Coordinates are given in rubyplot cordinates</span>
    <span class="c1"># Transform function handles deciding the position</span>
    <span class="c1"># in the figure</span>
    <span class="k">yield</span>
  <span class="k">else</span>
    <span class="c1"># Coordinates are not in rubyplot coordinates</span>
    <span class="c1"># Shifting to adjust incorporate the margin of the figure and axes</span>
    <span class="c1"># border! method can be used for figure margin but that will disturb rubyplot coordinates</span>
    <span class="c1"># i.e. rubyplot coordinates include the border spacing</span>
    <span class="n">x_shift</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">abs_x</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">left_margin</span><span class="p">)</span> <span class="o">*</span> <span class="vi">@canvas_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="c1"># in pixels</span>
    <span class="n">y_shift</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">abs_y</span> <span class="o">-</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">bottom_spacing</span> <span class="o">+</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">top_spacing</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">top_margin</span><span class="p">)</span> <span class="o">*</span> <span class="vi">@canvas_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="c1"># in pixels</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span>

    <span class="n">plottable_width</span> <span class="o">=</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">width</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">left_margin</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">right_margin</span><span class="p">)</span>
    <span class="n">plottable_height</span> <span class="o">=</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">height</span> <span class="o">-</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">bottom_margin</span> <span class="o">+</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">top_margin</span><span class="p">)</span>
    <span class="c1"># Scaling</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">,</span> <span class="n">plottable_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">,</span> <span class="n">plottable_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">plottable_width</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">,</span> <span class="n">plottable_height</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">)</span>

    <span class="c1"># Calling the block</span>
    <span class="k">yield</span>

    <span class="c1"># Rescaling</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="o">/</span> <span class="n">plottable_width</span><span class="p">,</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="o">/</span> <span class="n">plottable_height</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="o">/</span> <span class="n">plottable_width</span><span class="p">,</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="o">/</span> <span class="n">plottable_height</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span> <span class="o">/</span> <span class="n">plottable_width</span><span class="p">,</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span> <span class="o">/</span> <span class="n">plottable_height</span><span class="p">)</span>

    <span class="c1"># Reshifting to the original coordinates</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@text</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span>
    <span class="vi">@axes</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first checks the absolute flag and does nothing if it is true(as the coordinates are absolute and no shifting is required), if the absolute flag is false then the data used for drawing is in plot coordinates i.e. according to the data given by the user for the plot. So, if abs = false then there is a need to incorporate the margins for the figure as well as for the subplot and so the origin (upper left corner in magick) is shifted accordingly using Magick’s <strong>translate</strong> function which takes input as the amount(in pixels) by which X and Y origin is to be shifted, here we are not actually shifting the canvas but instead just the origin of the three Magick::Draw objects <em>draw</em>, <em>text, *axes</em> which actually draw shapes/text/axes on the canvas.<br> So, the amount by which the objects are to be shifted is to be given in pixels as Magick only accepts pixels and hence the coordinates present in Rubyplot coordinates are first divided by the maximum Rubyplot coordinate to bring the coordinate in the range [0,1] and then it is multiplied by the <em>canvas_width</em> to finally convert the coordinate into pixel value (remember the <em>canvas_width</em> was already scaled according to the <em>figsize_unit</em>). A similar operation is done for Y coordinate with a change that <em>top_margin</em> is incorporated as the origin for Magick backend is the upper left corner.</p> <p>After translation, scaling is done using <strong>scale</strong> function of Magick::Draw object which takes input the factor by which X and Y coordinates are to be scaled. This ensures that the drawing is scaled according to the requirements.</p> <p>After translation and scaling, the block is executed and the Draw object return to their original state by scaling and translating to the original state in which the Draw objects were present.</p> <p>After the <strong>within_window</strong> function, the X and Y coordinates are transformed to convert them into pixel values to be used further using the functions <strong>transform_x</strong> and <strong>transform_y</strong> which take the inputs, the coordinate to be transformed and the absolute flag. These functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Transform X co-ordinate.</span>
<span class="k">def</span> <span class="nf">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">abs</span>
    <span class="p">(</span><span class="vi">@canvas_width</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">*</span> <span class="n">x</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_x</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="p">((</span><span class="n">x</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">-</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">to_f</span> <span class="o">-</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_f</span><span class="p">))</span> <span class="o">*</span> <span class="vi">@canvas_width</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Transform Y co-ordinate</span>
<span class="k">def</span> <span class="nf">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">abs</span>
    <span class="p">(</span><span class="vi">@canvas_height</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">*</span> <span class="p">(</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">-</span> <span class="n">y</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span> <span class="o">/</span> <span class="vi">@figure</span><span class="p">.</span><span class="nf">max_y</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="p">((</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">to_f</span> <span class="o">-</span> <span class="n">y</span><span class="p">.</span><span class="nf">to_f</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="vi">@active_axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">to_f</span> <span class="o">-</span> <span class="vi">@active_axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">to_f</span><span class="p">))</span> <span class="o">*</span> <span class="vi">@canvas_height</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>In these functions, if the absolute flag is true i.e. the coordinates are in Rubyplot coordinates then similar to <strong>within_window</strong> function, the coordinates are first brought to the range [0,1] and then multiplied by the canvas dimensions to get the coordinates in pixels. The difference in Y coordinate is that in Magick the origin is the upper left corner but we want to make the origin as lower left corner and so the minimum Rubyplot coordinate actually refers to the highest point in the Figure and so we want to flip the position of points vertically and hence the coordinate is first subtracted from the maximum Rubyplot coordinates so that we get the desired plot.<br> Next, if the absolute flag is false i.e. the coordinates are not in Rubyplot coordinates and are according to the plot, the coordinate is brought to a range [0,1] by using minimum and maximum values of the data. And notice that similar to abs = true, the Y coordinate is scaled so that the position of points is flipped vertically. The <strong>x_range</strong> and <strong>y_range</strong> functions are:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">x_range</span>
  <span class="p">[</span><span class="vi">@x_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">,</span> <span class="vi">@x_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">]</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">y_range</span>
  <span class="p">[</span><span class="vi">@y_axis</span><span class="p">.</span><span class="nf">min_val</span><span class="p">,</span> <span class="vi">@y_axis</span><span class="p">.</span><span class="nf">max_val</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div> <p>These functions return the maximum and minimum values of X and Y axes across all the plots.</p> <p>After these functions, the useful properties for <em>text</em> variable is set for drawing. Also, the <em>color</em> variable which stores the symbol for the colour is converted to its RGB value which is stored in the <em>COLOR_INDEX</em> hash present in Color module. Next, the font is set if present, then <strong>pointsize</strong> function sets the size of the text in points unit. Then after setting the remaining useful properties, the text is to be drawn in the <em>text</em> variable which is a Magick::Draw object. But before that the <strong>modify_draw</strong> function is called which modifies a Magick::Draw object (or an array of such objects) for a temporary period until the block which is given as the input is executed, it takes in the inputs as the Magick::Draw object (or an array of such objects) which is to be modified, the amount of X and Y shift in pixels and the rotation. The function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">modify_draw</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="ss">x_shift: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">y_shift: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">scale_x: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">scale_y: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">rotation: </span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">draw</span> <span class="o">=</span> <span class="p">[</span><span class="n">draw</span><span class="p">]</span> <span class="k">unless</span> <span class="n">draw</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:each</span> <span class="c1"># Making draw iterable if not iterable</span>
  <span class="n">draw</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="n">x_shift</span><span class="p">,</span> <span class="n">y_shift</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_shift</span> <span class="o">&amp;&amp;</span> <span class="n">y_shift</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">rotate</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="k">if</span> <span class="n">rotation</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">)</span> <span class="k">if</span> <span class="n">scale_x</span> <span class="o">&amp;&amp;</span> <span class="n">scale_y</span>
  <span class="k">end</span>

  <span class="n">draw</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span>
    <span class="k">yield</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">draw</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">d</span><span class="o">|</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">scale</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">scale_x</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">scale_y</span><span class="p">)</span> <span class="k">if</span> <span class="n">scale_x</span> <span class="o">&amp;&amp;</span> <span class="n">scale_y</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">rotate</span><span class="p">(</span><span class="mf">90.0</span><span class="p">)</span> <span class="k">if</span> <span class="n">rotation</span>
    <span class="n">d</span><span class="p">.</span><span class="nf">translate</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">x_shift</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">y_shift</span><span class="p">)</span> <span class="k">if</span> <span class="n">x_shift</span> <span class="o">&amp;&amp;</span> <span class="n">y_shift</span>
  <span class="k">end</span>
  <span class="n">draw</span> <span class="o">=</span> <span class="n">draw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">unless</span> <span class="n">draw</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:each</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first makes the <em>draw</em> local variable iterable if it is not an array, then for each iten in the array it translates, scales and rotates the Draw object, then it executes the block and then returns the Draw object to its original state.<br> One important thing to keep in mind is that the Draw object is rotated with respect to its origin.</p> <p>So, we call the <strong>modify_draw</strong> function and then use the <strong>text</strong> of the Magick::Draw object to create a text on the required point. Here, we used the <strong>modify_draw</strong> function because we wanted to rotate the text correctly. So, first we translated the Magick::Draw object’s origin to where the text is to be drawn then we rotated the object with respect to the point where the text is to be drawn and then we drew the text at the point 0,0 which is actually the point where text is to be drawn as the origin of the Magick::Draw object is the point where the text was to be drawn.<br> Also, in the string <em>text</em> the ‘%’ is replaced with ‘%%’ using the <strong>gsub</strong> function so that Ruby does not interpret ‘%’ as a keyword.</p> <p>So, now the <strong>draw</strong> function of the X and Y axis has been executed and we return to <strong>draw</strong> function of the subplot i.e. the axes.</p> <p>The next command is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@texts</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
</code></pre></div></div> <p>which works in a similar way as described above (in <strong>draw</strong> of X and Y axes).</p> <p>Next, the code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@legend_box</span><span class="p">.</span><span class="nf">draw</span>
</code></pre></div></div> <p>which calls the <strong>draw</strong> function for <em>legend_box</em>:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="k">unless</span> <span class="vi">@legends</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="vi">@bounding_box</span><span class="p">.</span><span class="nf">draw</span>
    <span class="vi">@legends</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function only proceeds when there is at least one Legend object is present in <em>legends</em> array. If <em>legends</em> array is not empty then first the <strong>draw</strong> function is called for <em>bounding_box</em> which is actually a Rectangle object whose <strong>draw</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_rectangle</span><span class="p">(</span>
    <span class="ss">x1: </span><span class="vi">@x1</span><span class="p">,</span>
    <span class="ss">y1: </span><span class="vi">@y1</span><span class="p">,</span>
    <span class="ss">x2: </span><span class="vi">@x2</span><span class="p">,</span>
    <span class="ss">y2: </span><span class="vi">@y2</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@border_color</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@fill_color</span><span class="p">,</span>
    <span class="ss">abs: </span><span class="vi">@abs</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>which simply calls the <strong>draw_rectangle</strong> function of the backend and the inputs given to it are the x,y coordinates of the lower left and upper right corners, the colour of the border and the colour to be filled in the rectangle and finally the absolute flag (which is true here).<br> The <strong>draw_rectangle</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_rectangle</span><span class="p">(</span><span class="n">x1</span><span class="p">:,</span><span class="n">y1</span><span class="p">:,</span><span class="n">x2</span><span class="p">:,</span><span class="n">y2</span><span class="p">:,</span> <span class="ss">border_color: :default</span><span class="p">,</span>
        <span class="ss">fill_color: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">border_width: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">border_type: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="n">within_window</span><span class="p">(</span><span class="n">abs</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x1</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x2</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y1</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">y2</span><span class="p">,</span> <span class="ss">abs: </span><span class="n">abs</span><span class="p">)</span>

    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span> <span class="k">if</span> <span class="n">fill_color</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">stroke_width</span> <span class="n">border_width</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="c1"># if fill_color is not given, the rectangle fill colour is transparent</span>
    <span class="c1"># i.e. only edges are visible</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="mi">0</span> <span class="k">unless</span> <span class="n">fill_color</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">rectangle</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span>
    <span class="vi">@draw</span><span class="p">.</span><span class="nf">fill_opacity</span> <span class="mi">1</span> <span class="k">unless</span> <span class="n">fill_color</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>Here, first <strong>within_window</strong> is called which works the same as explained before, then the coordinates are transformed using <strong>transform_x</strong> and <strong>transform_y</strong> which work the same as explained before. Then the colour of the border and the colour to be filled are set using the <strong>stroke</strong> and <strong>fill</strong> functions of Magick::Draw respectively. The <em>COLOR_INDEX</em> hash is used to provide the colour in the correct format. Then the border width is set using <strong>stroke_width</strong> function. Then opacity is set to 0 if no colour is to be filled i.e. <em>fill_color</em> is not given i.e. it is nil. Finally, the <strong>rectangle</strong> function is called which takes in two opposite corners and draws the rectangle. And then the opacity is returned to 1 i.e. its original state.<br> P.S. - The rectangle is drawn in <em>draw</em> variable and the text was drawn in <em>text</em> variable.</p> <p>Now, the <strong>draw</strong> function for each Legend object is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="vi">@legend_color_box</span><span class="p">.</span><span class="nf">draw</span>
  <span class="vi">@text</span><span class="p">.</span><span class="nf">draw</span>
<span class="k">end</span>
</code></pre></div></div> <p>In this function, the <em>legend_color_box</em> and <em>text</em> call their <strong>draw</strong> function which is actually Rectangle and Text objects. We have already discussed the explanation for drawing these objects.</p> <h3 id="drawing-plots">Drawing plots</h3> <p>Returning to the <strong>draw</strong> function of the axes, the final line of code is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@plots</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:draw</span><span class="p">)</span>
</code></pre></div></div> <p>The <strong>draw</strong> function for each plot in <em>plots</em> array is called. In this example we have only one plot which is the scatter plot i.e. a Scatter object and hence the <strong>draw</strong> function of Scatter is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw</span>
  <span class="no">Rubyplot</span><span class="p">.</span><span class="nf">backend</span><span class="p">.</span><span class="nf">draw_markers</span><span class="p">(</span>
    <span class="ss">x: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">],</span>
    <span class="ss">y: </span><span class="vi">@data</span><span class="p">[</span><span class="ss">:y_values</span><span class="p">],</span>
    <span class="ss">type: </span><span class="vi">@marker_type</span><span class="p">,</span>
    <span class="ss">fill_color: </span><span class="vi">@marker_fill_color</span><span class="p">,</span>
    <span class="ss">border_color: </span><span class="vi">@marker_border_color</span><span class="p">,</span>
    <span class="ss">size: </span><span class="p">[</span><span class="vi">@marker_size</span><span class="p">]</span> <span class="o">*</span> <span class="vi">@data</span><span class="p">[</span><span class="ss">:x_values</span><span class="p">].</span><span class="nf">size</span>
  <span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>which simply calls the backend function <strong>draw_markers</strong> and the inputs given to it are the arrays containing the X and the Y data, the type of marker to be drawn, the colour to be filled in the marker and the border and finally an array of sizes of the markers(the size for all the markers is kept same). The <strong>draw_markers</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_markers</span><span class="p">(</span><span class="n">x</span><span class="p">:,</span> <span class="n">y</span><span class="p">:,</span> <span class="ss">type: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">fill_color: :default</span><span class="p">,</span> <span class="ss">border_color: :default</span><span class="p">,</span> <span class="ss">size: </span><span class="kp">nil</span><span class="p">)</span>
  <span class="n">y</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">iy</span><span class="p">,</span> <span class="n">idx_y</span><span class="o">|</span>
    <span class="n">ix</span> <span class="o">=</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">x</span><span class="p">[</span><span class="n">idx_y</span><span class="p">],</span><span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="n">iy</span> <span class="o">=</span> <span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">iy</span><span class="p">,</span> <span class="ss">abs: </span><span class="kp">false</span><span class="p">)</span>
    <span class="c1"># in GR backend size is multiplied by</span>
    <span class="c1"># nominal size generated on the graphics device</span>
    <span class="c1"># so setting the nominal_factor</span>
    <span class="n">nominal_factor</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">within_window</span> <span class="k">do</span>
      <span class="n">size</span><span class="p">[</span><span class="n">idx_y</span><span class="p">]</span> <span class="o">*=</span> <span class="n">nominal_factor</span>
      <span class="no">MARKER_TYPES</span><span class="p">[</span><span class="n">type</span><span class="p">].</span><span class="nf">call</span><span class="p">(</span><span class="vi">@draw</span><span class="p">,</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">[</span><span class="n">idx_y</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div> <p>In this function for each entry in the data (same for X or Y) a marker is drawn, so a loop is executed in which for each entry first the X and Y coordinates are transformed using <strong>transform_x</strong> and <strong>transform_y</strong> functions (explained earlier). Then the size is multiplied by a <em>nominal_factor</em> to make the backends consistent. In GR backend, the size is multiplied by the nominal size generated on the graphics device(the value is not disclosed) and so for Magick backend <em>nominal_factor</em> is chosen as 15 (found through trial and error by comparing the same figures for both backends). Now, the <strong>within_window</strong> function is called (explained earlier) and size is multiplied by the <em>nominal_factor</em>. Then the marker is drawn in the <em>draw</em> object using the <em>MARKER_TYPES</em> which stores lambdas for drawing the markers and so according to the <em>type</em> the lambda stored in <em>MARKER_TYPES</em> is called using <strong>call</strong>. Each of the Lambda takes in input the Magick::Draw object, the x,y coordinates (in pixels), the colour to be filled, the border colour and the size of the marker.</p> <p>In this example, the types of the marker is <em>:circle</em> and the Lambda for it is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">MARKER_TYPES</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1"># Default type is circle</span>
  <span class="c1"># Stroke width is set to 1</span>
  <span class="ss">nil: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">circle: </span><span class="o">-&gt;</span><span class="p">(</span><span class="n">draw</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fill_color</span><span class="p">,</span> <span class="n">border_color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">stroke</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">border_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">fill</span> <span class="no">Rubyplot</span><span class="o">::</span><span class="no">Color</span><span class="o">::</span><span class="no">COLOR_INDEX</span><span class="p">[</span><span class="n">fill_color</span><span class="p">]</span>
    <span class="n">draw</span><span class="p">.</span><span class="nf">circle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="c1"># Code for rest of the markers is not shown because of space constraints</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <em>:circle</em> Lambda first sets the colour of the border and the colour to be filled and then it calls the <strong>circle</strong> function for the Magick::Draw object stored in <em>draw</em> local variable to draw a circle. The function takes in inputs as the x,y coordinates for the centre and a point at the circumference (in pixel values). So, the marker is drawn in the <em>draw</em> variable.</p> <p>We now return to the <strong>write</strong> function of the Figure.</p> <h3 id="writing-figure-backend">Writing Figure (Backend)</h3> <p>Now, the <strong>write</strong> function of the backend is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write</span>
  <span class="n">draw_axes</span>
  <span class="vi">@draw</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="vi">@text</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
  <span class="vi">@base_image</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="vi">@file_name</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first calls the <strong>draw_axes</strong> which will draw the <em>axes</em> Magick::Draw object onto the Magick::Image object <em>base_image</em> which is the canvas. Then the <strong>draw</strong> function is called for the Magick::Draw objects <em>draw</em> and <em>text</em> and the input is given is <em>base_image</em>, so the Magick::Draw objects are drawn onto the canvas i.e. Magick::Image object. And finally, the <strong>write</strong> function is called for <em>base_image</em> which is a Magick::Image, the function takes the input a string which would be the name of the file(image) when saved and so the <em>base_image</em> is written onto the device.<br> The <strong>draw_axes</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_axes</span>
  <span class="vi">@axes_map</span><span class="p">.</span><span class="nf">each_value</span> <span class="k">do</span> <span class="o">|</span><span class="n">v</span><span class="o">|</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="ss">:axes</span><span class="p">]</span>
    <span class="vi">@active_axes</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="n">within_window</span> <span class="k">do</span>
      <span class="c1"># Plot the X and Y axes</span>
      <span class="vi">@axes</span><span class="p">.</span><span class="nf">polyline</span><span class="p">(</span>
        <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">v</span><span class="p">[</span><span class="ss">:x_origin</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">v</span><span class="p">[</span><span class="ss">:y_origin</span><span class="p">]),</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">axes</span><span class="p">.</span><span class="nf">x_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">v</span><span class="p">[</span><span class="ss">:y_origin</span><span class="p">]),</span>
        <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">v</span><span class="p">[</span><span class="ss">:x_origin</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">v</span><span class="p">[</span><span class="ss">:y_origin</span><span class="p">]),</span> <span class="n">transform_x</span><span class="p">(</span><span class="ss">x: </span><span class="n">v</span><span class="p">[</span><span class="ss">:x_origin</span><span class="p">]),</span><span class="n">transform_y</span><span class="p">(</span><span class="ss">y: </span><span class="n">axes</span><span class="p">.</span><span class="nf">y_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="vi">@axes</span><span class="p">.</span><span class="nf">draw</span><span class="p">(</span><span class="vi">@base_image</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function is used to draw the X and Y axis using the <em>axes_map</em> hash. Now, for every key in the <em>axes_map</em> hash first the <em>axes</em> variable is set as the subplot(axes) for which the X and Y axes is to be drawn, then the <em>active_axes</em> is set as the subplot. Then the <strong>within_window</strong> function is called (explained earlier) and then the <strong>polyline</strong> function is called for <em>axes</em> magick::Draw object which draws multiple line by taking the inputs as multiple x,y coordinate pairs for starting and ending points of the lines (in pixels). So, the inputs given to draw the X axis are the transformed points origin of the <em>axes</em> and the maximum value of X, Y origin. For the Y axis, the inputs given are the transformed points origin of the <em>axes</em> and the X origin, maximum value of Y.</p> <p>Finally, the <em>axes</em> Magick::Draw object is drawn using the <strong>draw</strong> function on the <em>base_image</em> Magick::image object (canvas).</p> <p>We now return to the <strong>write</strong> function of the Figure to execute the last line of code. Notice that we have already drawn and saved the figure.</p> <h2 id="finishing-up">Finishing up</h2> <p>Finally the backend’s <strong>stop_output_device</strong> function is called:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stop_output_device</span>
  <span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span> <span class="o">=</span> <span class="n">unscale_figure</span><span class="p">(</span><span class="vi">@canvas_width</span><span class="p">,</span> <span class="vi">@canvas_height</span><span class="p">)</span>
  <span class="n">flush</span>
<span class="k">end</span>
</code></pre></div></div> <p>This function first scales the canvas dimensions to its original values by calling <strong>unscale_figure</strong> which were scaled according to the <em>figsize_units</em> variable. Then the <strong>flush</strong> function is called which clears the memory by disposing of data which is no longer useful.</p> <p>The <strong>unscale_figure</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">unscale_figure</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
  <span class="p">[</span><span class="n">width</span> <span class="o">/</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">],</span> <span class="n">height</span> <span class="o">/</span> <span class="no">PIXEL_MULTIPLIERS</span><span class="p">[</span><span class="vi">@figure</span><span class="p">.</span><span class="nf">figsize_unit</span><span class="p">]]</span>
<span class="k">end</span>
</code></pre></div></div> <p>The width and the height are divided by the conversion constants set in the <em>PIXEL_MULTIPLIERS</em> hash (explained earlier). So, the Figure dimensions are scaled back to its original values.</p> <p>The <strong>flush</strong> function is:</p> <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Refresh this backend and remove all previously set data.</span>
<span class="k">def</span> <span class="nf">flush</span>
  <span class="vi">@axes_map</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@file_name</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div> <p>First the <em>axes_map</em> is cleared and then the <em>file_name</em> is cleared. This refreshes the backend and clears the memory.</p> <p><strong>So, we have finally drawn, written and saved our figure.</strong></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/gsoc2019/2019/08/22/Wrapping-up-GSoC-2019/">Wrapping up GSoC 2019</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/gsoc2019/2019/08/22/IRuby-integration-and-ticks/">IRuby integration and ticks</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/gsoc2019/2019/07/26/The-show-and-the-plot-functions/">The show and the plot functions</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/gsoc2019/2019/07/13/Multi-plots-in-Rubyplot/">Multi plots in Rubyplot</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/gsoc2019/2019/06/28/Simple-Plots-in-Rubyplot/">Simple Plots in Rubyplot</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Alish Dipani. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?601a2d3465e2a52bec38b600518d5f70"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-home",title:"Home",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-journals",title:"Journals",description:"",section:"Navigation",handler:()=>{window.location.href="/journals/"}},{id:"nav-conferences",title:"Conferences",description:"",section:"Navigation",handler:()=>{window.location.href="/conferences/"}},{id:"nav-teaching",title:"Teaching",description:"",section:"Navigation",handler:()=>{window.location.href="/teaching/"}},{id:"nav-awards",title:"Awards",description:"",section:"Navigation",handler:()=>{window.location.href="/awards/"}},{id:"nav-service",title:"Service",description:"",section:"Navigation",handler:()=>{window.location.href="/service/"}},{id:"nav-blog",title:"Blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"dropdown-invited-talks",title:"Invited Talks",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"dropdown-experience",title:"Experience",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"dropdown-open-source",title:"Open-source",description:"",section:"Dropdown",handler:()=>{window.location.href=""}},{id:"post-wrapping-up-gsoc-2019",title:"Wrapping up GSoC 2019",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/08/22/Wrapping-up-GSoC-2019/"}},{id:"post-iruby-integration-and-ticks",title:"IRuby integration and ticks",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/08/22/IRuby-integration-and-ticks/"}},{id:"post-the-show-and-the-plot-functions",title:"The show and the plot functions",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/07/26/The-show-and-the-plot-functions/"}},{id:"post-multi-plots-in-rubyplot",title:"Multi plots in Rubyplot",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/07/13/Multi-plots-in-Rubyplot/"}},{id:"post-simple-plots-in-rubyplot",title:"Simple Plots in Rubyplot",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/06/28/Simple-Plots-in-Rubyplot/"}},{id:"post-the-scatter-plot-example",title:"The Scatter plot example",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/06/10/The-Scatter-plot-example/"}},{id:"post-rubyplot-installation-guide",title:"Rubyplot installation guide",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/06/09/Rubyplot-installation-guide/"}},{id:"post-gsoc-2019-project-introduction",title:"GSoC 2019 project introduction",description:"",section:"Posts",handler:()=>{window.location.href="/gsoc2019/2019/06/08/GSoC-2019-project-introduction/"}},{id:"post-neural-style-transfer-on-audio-signals",title:"Neural Style Transfer on Audio Signals",description:"",section:"Posts",handler:()=>{window.location.href="/projects/2018/08/Neural-Style-Transfer-Audio/"}},{id:"news-i-will-be-a-lead-ta-for-the-neuroai-https-neuroai-neuromatch-io-tutorials-intro-html-neuromatch-academy",title:"I will be a Lead TA for the [NeuroAI](https://neuroai.neuromatch.io/tutorials/intro.html) Neuromatch Academy",description:"",section:"News"},{id:"news-i-created-a-tutorial-on-normalization-https-neuroai-neuromatch-io-tutorials-w1d5-microcircuits-student-w1d5-tutorial2-html-for-the-neuroai-https-neuroai-neuromatch-io-tutorials-intro-html-neuromatch-academy",title:"I created a tutorial on [Normalization](https://neuroai.neuromatch.io/tutorials/W1D5_Microcircuits/student/W1D5_Tutorial2.html) for the [NeuroAI](https://neuroai.neuromatch.io/tutorials/intro.html) Neuromatch Academy",description:"",section:"News"},{id:"news-our-commentary-paper-quot-linking-faces-to-social-cognition-the-temporal-pole-as-a-potential-social-switch-https-www-pnas-org-doi-abs-10-1073-pnas-2411735121-quot-has-been-published-in-pnas",title:"Our commentary paper &quot;[Linking faces to social cognition: The temporal pole as a...",description:"",section:"News"},{id:"news-i-will-be-giving-a-talk-at-sinha-lab-department-of-brain-amp-cognitive-sciences-mit-usa",title:"I will be giving a talk at Sinha Lab, Department of Brain &amp;...",description:"",section:"News"},{id:"news-i-will-be-joining-the-psychology-phd-program-at-georgiatech-as-a-coco-fellow-https-coco-psych-gatech-edu",title:"I will be joining the Psychology PhD program at GeorgiaTech as a [CoCo...",description:"",section:"News"},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%61%6C%69%73%68.%64%69%70%61%6E%69@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=i028n20AAAAJ","_blank")}},{id:"socials-youtube",title:"YouTube",section:"Socials",handler:()=>{window.open("https://youtube.com/@alishdipwni","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>